import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";
import { EffectComposer } from "https://unpkg.com/three@0.160.1/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://unpkg.com/three@0.160.1/examples/jsm/postprocessing/RenderPass.js";
import { SSAOPass } from "https://unpkg.com/three@0.160.1/examples/jsm/postprocessing/SSAOPass.js";
import { UnrealBloomPass } from "https://unpkg.com/three@0.160.1/examples/jsm/postprocessing/UnrealBloomPass.js";
import { RGBELoader } from "https://unpkg.com/three@0.160.1/examples/jsm/loaders/RGBELoader.js";

const app = document.getElementById("app");
const scoreValue = document.getElementById("scoreValue");
const bestValue = document.getElementById("bestValue");
const difficultyValue = document.getElementById("difficultyValue");
const levelValue = document.getElementById("levelValue");
const rewardValue = document.getElementById("rewardValue");
const speedValue = document.getElementById("speedValue");
const comboValue = document.getElementById("comboValue");
const boostValue = document.getElementById("boostValue");
const renderStatsValue = document.getElementById("renderStatsValue");
const statusPanel = document.getElementById("statusPanel");
const statusText = document.getElementById("statusText");
const startButton = document.getElementById("startButton");
const pauseButton = document.getElementById("pauseButton");
const leftButton = document.getElementById("leftButton");
const rightButton = document.getElementById("rightButton");
const eventTicker = document.getElementById("eventTicker");

const STORAGE_KEY = "highway_escape_best";

const BASE_EXPOSURE = 1.02;
const DEFAULT_QUALITY_LEVEL = 1;
const DETERMINISTIC_SEED = 20260208;
const WORLD_GENERATION_SEED = 90210;
const TERRAIN_TEXTURE_SEED = 77231;
const qualityPresets = {
  1: {
    shadowMapSize: 1024,
    aoEnabled: false,
    aoIntensity: 0.0,
    aoRadius: 2.0,
    bloomEnabled: false,
    bloomStrength: 0.0,
    bloomThreshold: 0.92,
    instanceDensity: 0.68,
    fogDensityScale: 1.16,
    maxPixelRatio: 1.2
  },
  2: {
    shadowMapSize: 1536,
    aoEnabled: true,
    aoIntensity: 0.18,
    aoRadius: 4.0,
    bloomEnabled: true,
    bloomStrength: 0.11,
    bloomThreshold: 0.92,
    instanceDensity: 0.92,
    fogDensityScale: 1.0,
    maxPixelRatio: 1.7
  },
  3: {
    shadowMapSize: 2048,
    aoEnabled: true,
    aoIntensity: 0.26,
    aoRadius: 6.0,
    bloomEnabled: true,
    bloomStrength: 0.16,
    bloomThreshold: 0.9,
    instanceDensity: 1.0,
    fogDensityScale: 0.9,
    maxPixelRatio: 2.0
  }
};

const randomNative = Math.random.bind(Math);
let deterministicRandom = createSeededRng(DETERMINISTIC_SEED);
let deterministicMode = false;

function readBestScore() {
  try {
    const raw = window.localStorage.getItem(STORAGE_KEY);
    const parsed = Number(raw || "0");
    return Number.isFinite(parsed) ? parsed : 0;
  } catch (_err) {
    return 0;
  }
}

function writeBestScore(value) {
  try {
    window.localStorage.setItem(STORAGE_KEY, String(Math.floor(value)));
  } catch (_err) {
    // Ignore write failures in restricted environments.
  }
}

const renderer = initRenderer(app);
const scene = new THREE.Scene();
const skyTexture = withSeededRandom(WORLD_GENERATION_SEED, () => createSkyTexture());
scene.background = skyTexture;
scene.fog = new THREE.Fog(0xb9c9d8, 70, 390);

const camera = new THREE.PerspectiveCamera(56, window.innerWidth / window.innerHeight, 0.1, 420);
const cameraRig = {
  desktopPosition: new THREE.Vector3(0, 6.6, 34),
  desktopLookAt: new THREE.Vector3(0, 1.6, 2),
  mobilePosition: new THREE.Vector3(0, 7.3, 37),
  mobileLookAt: new THREE.Vector3(0, 1.8, 4),
  positionTarget: new THREE.Vector3(),
  lookAtTarget: new THREE.Vector3()
};
camera.position.copy(cameraRig.desktopPosition);
camera.lookAt(cameraRig.desktopLookAt);

const lighting = initLighting(scene, renderer, skyTexture);
const hemi = lighting.hemi;
const sun = lighting.sun;
const fill = lighting.fill;
const bounce = lighting.bounce;
const moon = lighting.moon;
const postFx = initPostFX(renderer, scene, camera);

const visualState = {
  daylight: 0.78,
  rainStrength: 0.48,
  stormBlend: 0.5,
  wetness: 0.62,
  windDrift: 0.0
};

const visualColors = {
  fogDay: new THREE.Color(0xb9c9d8),
  fogDusk: new THREE.Color(0x8192a7),
  fogNight: new THREE.Color(0x2d3f52),
  hemiSkyDay: new THREE.Color(0xe8f2ff),
  hemiSkyNight: new THREE.Color(0x7d9fd2),
  hemiGroundDay: new THREE.Color(0x43503d),
  hemiGroundNight: new THREE.Color(0x1e2a37),
  sunDay: new THREE.Color(0xfff4dd),
  sunDusk: new THREE.Color(0xffc08b)
};
const tempColorA = new THREE.Color();
const tempColorB = new THREE.Color();

const params = {
  laneWidth: 4.2,
  roadWidth: 15.2,
  roadLength: 520,
  spawnZ: -236,
  recycleZ: 104,
  playerZ: 26,
  playerHitWidth: 1.95,
  playerHitDepth: 4.05
};
const laneCenters = [-params.laneWidth, 0, params.laneWidth];
const LEVEL_TIME_MIN_SECONDS = 20;

function buildLevelGoal(level) {
  return {
    targetScore: 760 + (level - 1) * 260,
    targetRewards: Math.min(9, 3 + Math.floor((level - 1) / 2)),
    timeLimit: Math.max(LEVEL_TIME_MIN_SECONDS, 36 - (level - 1) * 1.4)
  };
}

const environment = withSeededRandom(
  WORLD_GENERATION_SEED + 1,
  () => buildEnvironment(scene, params, renderer, qualityPresets[DEFAULT_QUALITY_LEVEL])
);

const player = buildPlayerCar();
player.group.position.set(0, 0, params.playerZ);
scene.add(player.group);

const obstacleGroup = new THREE.Group();
scene.add(obstacleGroup);
const collectibleGroup = new THREE.Group();
scene.add(collectibleGroup);

const state = {
  running: false,
  paused: false,
  gameOver: false,
  score: 0,
  difficulty: 1,
  level: 1,
  laneIndex: 1,
  laneTargetX: laneCenters[1],
  worldSpeed: 30.5,
  speedKmh: 225,
  spawnTimer: 0,
  collectSpawnTimer: 0,
  startedAt: performance.now(),
  obstacles: [],
  collectibles: [],
  rewardsCollected: 0,
  comboCount: 0,
  comboTimer: 0,
  comboMultiplier: 1,
  boostTimer: 0,
  levelScoreStart: 0,
  levelRewardStart: 0,
  levelTargetScore: 760,
  levelTargetRewards: 3,
  levelTimeLimit: 36,
  levelTimeLeft: 36,
  eventEndsAt: 0,
  eventTone: "reward",
  bestScore: readBestScore(),
  qualityLevel: DEFAULT_QUALITY_LEVEL,
  deterministicMode: false
};

let simulationTimeMs = performance.now();
const runtimeStats = {
  fps: 0,
  fpsAccumulator: 0,
  frameAccumulator: 0
};
let postFxDisabledByError = false;

function setStatus(message) {
  statusText.textContent = message;
}

function showStatus(show) {
  statusPanel.style.display = show ? "block" : "none";
}

function pushEvent(message, tone = "reward", durationSeconds = 1.45) {
  if (!eventTicker) return;
  eventTicker.textContent = message;
  state.eventTone = tone;
  state.eventEndsAt = simulationTimeMs + durationSeconds * 1000;
  eventTicker.className = "";
  eventTicker.classList.add("visible");
  if (tone) {
    eventTicker.classList.add(tone);
  }
}

function updateEventTicker() {
  if (!eventTicker) return;
  if (simulationTimeMs >= state.eventEndsAt) {
    eventTicker.className = "";
  }
}

function getLevelProgress() {
  return {
    score: Math.max(0, state.score - state.levelScoreStart),
    rewards: Math.max(0, state.rewardsCollected - state.levelRewardStart)
  };
}

function applyLevelGoal(level, announce = false) {
  const goal = buildLevelGoal(level);
  state.level = level;
  state.levelScoreStart = state.score;
  state.levelRewardStart = state.rewardsCollected;
  state.levelTargetScore = goal.targetScore;
  state.levelTargetRewards = goal.targetRewards;
  state.levelTimeLimit = goal.timeLimit;
  state.levelTimeLeft = goal.timeLimit;

  if (announce) {
    pushEvent(
      `Level ${state.level}: ${goal.targetScore} score + ${goal.targetRewards} rewards.`,
      "level",
      2.2
    );
  }
}

function updateHud() {
  const levelProgress = getLevelProgress();
  scoreValue.textContent = String(Math.floor(state.score));
  bestValue.textContent = String(Math.floor(state.bestScore));
  difficultyValue.textContent = `${state.difficulty.toFixed(1)}x`;
  if (levelValue) levelValue.textContent = `${state.level} (${Math.ceil(state.levelTimeLeft)}s)`;
  if (rewardValue) rewardValue.textContent = `${Math.floor(levelProgress.rewards)}/${state.levelTargetRewards}`;
  if (speedValue) speedValue.textContent = `${Math.round(state.speedKmh)} km/h`;
  if (comboValue) comboValue.textContent = `x${state.comboMultiplier.toFixed(1)}`;
  if (boostValue) boostValue.textContent = state.boostTimer > 0 ? `${state.boostTimer.toFixed(1)}s` : "READY";
  if (renderStatsValue) {
    const fpsText = runtimeStats.fps > 0 ? runtimeStats.fps.toFixed(0) : "--";
    renderStatsValue.textContent = `FPS ${fpsText} | ${Math.round(state.speedKmh)} km/h | Q${state.qualityLevel} | DET ${state.deterministicMode ? "ON" : "OFF"}`;
  }
  if (pauseButton) {
    pauseButton.textContent = state.paused ? "Resume" : "Pause";
  }
}

function clampLaneIndex(index) {
  return Math.max(0, Math.min(laneCenters.length - 1, index));
}

function moveLane(delta) {
  if (!state.running || state.paused || state.gameOver) return;
  state.laneIndex = clampLaneIndex(state.laneIndex + delta);
  state.laneTargetX = laneCenters[state.laneIndex];
}

function clearObstacles() {
  for (const item of state.obstacles) {
    obstacleGroup.remove(item.mesh);
    disposeObject3D(item.mesh);
  }
  state.obstacles = [];
}

function clearCollectibles() {
  for (const item of state.collectibles) {
    collectibleGroup.remove(item.mesh);
    disposeObject3D(item.mesh);
  }
  state.collectibles = [];
}

function startGame() {
  state.running = true;
  state.paused = false;
  state.gameOver = false;
  state.score = 0;
  state.difficulty = 1;
  state.worldSpeed = 30.5;
  state.speedKmh = 225;
  state.spawnTimer = 0.12;
  state.collectSpawnTimer = 1.2;
  state.startedAt = simulationTimeMs;
  state.rewardsCollected = 0;
  state.comboCount = 0;
  state.comboTimer = 0;
  state.comboMultiplier = 1;
  state.boostTimer = 0;
  applyLevelGoal(1);
  state.eventEndsAt = 0;
  state.laneIndex = 1;
  state.laneTargetX = laneCenters[state.laneIndex];
  player.group.position.x = state.laneTargetX;
  player.group.position.y = 0;
  player.group.rotation.set(0, 0, 0);
  clearObstacles();
  clearCollectibles();
  showStatus(false);
  pushEvent(
    `Level 1 target: ${state.levelTargetScore} score + ${state.levelTargetRewards} rewards.`,
    "level",
    2.2
  );
  updateHud();
}

function endGame(reason = "crash") {
  state.running = false;
  state.paused = false;
  state.gameOver = true;
  if (state.score > state.bestScore) {
    state.bestScore = state.score;
    writeBestScore(state.bestScore);
  }
  if (reason === "timeout") {
    setStatus(`Time up on level ${state.level}. Final score ${Math.floor(state.score)}. Press Start to retry.`);
    pushEvent("Level timer expired. Run ended.", "danger", 1.9);
  } else {
    setStatus(`Crash detected. Final score ${Math.floor(state.score)}. Press Start to run again.`);
    pushEvent("Vehicle damaged. Run ended.", "level", 1.6);
  }
  showStatus(true);
  updateHud();
}

function togglePause() {
  if (!state.running || state.gameOver) return;
  state.paused = !state.paused;
  if (state.paused) {
    setStatus("Paused. Press Resume to continue.");
    showStatus(true);
    pushEvent("Simulation paused.", "level", 1.1);
  } else {
    showStatus(false);
    pushEvent("Simulation resumed.", "level", 1.1);
  }
  updateHud();
}

function toggleFullscreen() {
  if (!document.fullscreenElement) {
    app.requestFullscreen().catch(() => {
      // Ignore unsupported fullscreen requests.
    });
  } else {
    document.exitFullscreen().catch(() => {
      // Ignore exit failures on restricted platforms.
    });
  }
}

function exportFramePng() {
  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  const anchor = document.createElement("a");
  anchor.download = `highway_escape_${stamp}.png`;
  anchor.href = renderer.domElement.toDataURL("image/png");
  anchor.click();
  pushEvent("PNG frame exported.", "reward", 1.2);
}

function setDeterministicMode(enabled) {
  const target = Boolean(enabled);
  if (target === state.deterministicMode) return;

  state.deterministicMode = target;
  deterministicMode = target;
  if (target) {
    deterministicRandom = createSeededRng(DETERMINISTIC_SEED);
    Math.random = () => deterministicRandom();
    simulationTimeMs = 0;
    lastTime = performance.now();
    camera.position.copy(cameraRig.desktopPosition);
    cameraRig.positionTarget.copy(cameraRig.desktopPosition);
    cameraRig.lookAtTarget.copy(cameraRig.desktopLookAt);
    camera.lookAt(cameraRig.desktopLookAt);
    startGame();
    pushEvent("Deterministic mode ON (fixed seed/time-step).", "level", 1.8);
  } else {
    Math.random = randomNative;
    lastTime = performance.now();
    pushEvent("Deterministic mode OFF.", "level", 1.2);
  }
  updateHud();
}

function setQualityLevel(level, announce = true) {
  const next = Math.max(1, Math.min(3, Math.floor(level)));
  if (next === state.qualityLevel) return;
  state.qualityLevel = next;
  applyQualityPreset(qualityPresets[next], environment, renderer, postFx, sun);
  handleResize();
  if (announce) {
    pushEvent(`Quality Q${next} applied.`, "level", 1.1);
  }
  updateHud();
}

function spawnObstacle() {
  const lane = laneCenters[Math.floor(Math.random() * laneCenters.length)];
  const roll = Math.random();

  let obstacle;
  if (roll < 0.44) {
    obstacle = createBarrierObstacle();
  } else if (roll < 0.74) {
    obstacle = createConeClusterObstacle();
  } else {
    obstacle = createTrafficCarObstacle();
  }

  obstacle.mesh.position.x = lane;
  obstacle.mesh.position.z = params.spawnZ;
  obstacle.mesh.position.y = 0;
  obstacleGroup.add(obstacle.mesh);

  state.obstacles.push({
    ...obstacle,
    passed: false,
    pulseSeed: Math.random() * Math.PI * 2
  });
}

function spawnCollectible() {
  const lane = laneCenters[Math.floor(Math.random() * laneCenters.length)];
  const roll = Math.random();
  const collectible = roll < 0.26 ? createNitroReward() : createCoinReward();

  collectible.mesh.position.x = lane;
  collectible.mesh.position.z = params.spawnZ - 22 - Math.random() * 20;
  collectible.mesh.position.y = collectible.height;
  collectibleGroup.add(collectible.mesh);

  state.collectibles.push({
    ...collectible,
    lane,
    seed: Math.random() * Math.PI * 2
  });
}

function hasObstacleCollision(obstacle) {
  const dx = Math.abs(obstacle.mesh.position.x - player.group.position.x);
  if (dx > (obstacle.width + params.playerHitWidth) * 0.5) return false;

  const dz = Math.abs(obstacle.mesh.position.z - params.playerZ);
  return dz < (obstacle.depth + params.playerHitDepth) * 0.5;
}

function hasCollectiblePickup(collectible) {
  const dx = Math.abs(collectible.mesh.position.x - player.group.position.x);
  if (dx > (collectible.width + params.playerHitWidth) * 0.5) return false;

  const dz = Math.abs(collectible.mesh.position.z - params.playerZ);
  return dz < (collectible.depth + params.playerHitDepth) * 0.5;
}

function applyCollectibleReward(collectible) {
  state.rewardsCollected += 1;
  state.comboCount = state.comboTimer > 0 ? state.comboCount + 1 : 1;
  state.comboTimer = 4.2;
  state.comboMultiplier = Math.min(3.4, 1 + (state.comboCount - 1) * 0.22);

  const comboScore = collectible.baseScore * state.comboMultiplier;
  state.score += comboScore;

  if (collectible.type === "nitro") {
    state.boostTimer = Math.min(6.5, state.boostTimer + 2.4);
    pushEvent(`Nitro +2.4s  Combo x${state.comboMultiplier.toFixed(1)}`, "boost");
  } else {
    pushEvent(`Reward +${Math.round(comboScore)}  Combo x${state.comboMultiplier.toFixed(1)}`, "reward");
  }
}

function updateObstacles(dt, nowSeconds) {
  const spawnInterval = Math.max(0.34, 1.14 - state.difficulty * 0.08 - (state.level - 1) * 0.015);
  state.spawnTimer -= dt;
  if (state.spawnTimer <= 0) {
    spawnObstacle();
    state.spawnTimer = spawnInterval;
  }

  for (let i = state.obstacles.length - 1; i >= 0; i -= 1) {
    const obstacle = state.obstacles[i];
    obstacle.mesh.position.z += state.worldSpeed * dt;

    if (obstacle.beacons) {
      for (let j = 0; j < obstacle.beacons.length; j += 1) {
        const pulse = 0.72 + 0.58 * Math.max(0, Math.sin(nowSeconds * 9 + obstacle.pulseSeed + j * 0.9));
        obstacle.beacons[j].material.emissiveIntensity = pulse;
      }
    }

    if (!obstacle.passed && obstacle.mesh.position.z > params.playerZ + 2.5) {
      obstacle.passed = true;
      state.score += 40 * state.difficulty;
    }

    if (hasObstacleCollision(obstacle)) {
      endGame();
      return;
    }

    if (obstacle.mesh.position.z > params.recycleZ) {
      obstacleGroup.remove(obstacle.mesh);
      disposeObject3D(obstacle.mesh);
      state.obstacles.splice(i, 1);
    }
  }
}

function updateCollectibles(dt, nowSeconds) {
  const spawnInterval = Math.max(0.78, 2.2 - state.level * 0.07);
  state.collectSpawnTimer -= dt;
  if (state.collectSpawnTimer <= 0) {
    spawnCollectible();
    state.collectSpawnTimer = spawnInterval + Math.random() * 0.35;
  }

  for (let i = state.collectibles.length - 1; i >= 0; i -= 1) {
    const collectible = state.collectibles[i];
    collectible.mesh.position.z += state.worldSpeed * dt;
    collectible.mesh.rotation.y += collectible.spinSpeed * dt;
    collectible.mesh.position.y = collectible.height + Math.sin(nowSeconds * 4 + collectible.seed) * 0.08;

    if (collectible.glow) {
      collectible.glow.material.emissiveIntensity =
        collectible.glowBase + Math.sin(nowSeconds * 8 + collectible.seed) * 0.34;
    }

    if (hasCollectiblePickup(collectible)) {
      applyCollectibleReward(collectible);
      collectibleGroup.remove(collectible.mesh);
      disposeObject3D(collectible.mesh);
      state.collectibles.splice(i, 1);
      continue;
    }

    if (collectible.mesh.position.z > params.recycleZ + 3) {
      collectibleGroup.remove(collectible.mesh);
      disposeObject3D(collectible.mesh);
      state.collectibles.splice(i, 1);
    }
  }
}

function updatePlayer(dt, nowMs) {
  const laneBlend = Math.min(1, dt * 9.2);
  const deltaX = state.laneTargetX - player.group.position.x;
  player.group.position.x += deltaX * laneBlend;

  const rollTarget = -deltaX * 0.085;
  player.group.rotation.z += (rollTarget - player.group.rotation.z) * Math.min(1, dt * 10.5);

  const pitchTarget = -0.014 + Math.sin(nowMs * 0.0046) * 0.006;
  player.group.rotation.x += (pitchTarget - player.group.rotation.x) * Math.min(1, dt * 6.5);

  const bounce = state.running && !state.paused && !state.gameOver ? Math.sin(nowMs * 0.012) * 0.04 : 0;
  player.group.position.y = bounce;

  const activeRun = state.running && !state.paused && !state.gameOver;
  const wheelSpin = activeRun ? state.worldSpeed * dt * 2.1 : 0;
  for (const wheel of player.wheels) {
    wheel.rotation.x -= wheelSpin;
  }

  const boost = activeRun ? (state.boostTimer > 0 ? 1.28 : 0.95) : 0.55;
  for (const lamp of player.headlights) {
    lamp.material.emissiveIntensity = boost;
  }

  const nightFactor = 1 - visualState.daylight;
  const beamIntensity = activeRun
    ? 0.5 + nightFactor * 1.6 + visualState.rainStrength * 0.32 + (state.boostTimer > 0 ? 0.24 : 0)
    : 0.26 + nightFactor * 0.6;
  const beamDistance = 36 + state.worldSpeed * 0.28;
  for (const beam of player.headlightBeams) {
    beam.intensity = beamIntensity;
    beam.distance = beamDistance;
  }
}

function updateAtmosphere(dt, nowSeconds) {
  const dayCycleSeconds = 168;
  const dayPhase = (nowSeconds % dayCycleSeconds) / dayCycleSeconds;
  const arc = dayPhase * Math.PI * 2;
  const sunLift = Math.sin(arc - Math.PI * 0.2);

  const daylightTarget = THREE.MathUtils.clamp(0.2 + Math.max(0, sunLift) * 0.9, 0.12, 1.0);
  visualState.daylight += (daylightTarget - visualState.daylight) * Math.min(1, dt * 0.42);

  const stormWave = 0.5 + 0.5 * Math.sin(nowSeconds * 0.11 + Math.sin(nowSeconds * 0.03) * 0.9);
  const stormTarget = THREE.MathUtils.clamp(0.22 + stormWave * 0.75, 0.22, 0.96);
  visualState.stormBlend += (stormTarget - visualState.stormBlend) * Math.min(1, dt * 0.35);

  visualState.rainStrength = 0.2 + visualState.stormBlend * 0.72;
  visualState.wetness = THREE.MathUtils.clamp(0.34 + visualState.rainStrength * 0.58, 0.32, 0.9);
  visualState.windDrift = Math.sin(nowSeconds * 0.45) * 0.6 + Math.sin(nowSeconds * 0.14) * 0.18;

  sun.position.set(-24 + Math.cos(arc) * 58, 10 + visualState.daylight * 34, -30 + Math.sin(arc) * 42);
  sun.intensity = 0.32 + visualState.daylight * 1.06;

  fill.intensity = 0.16 + visualState.daylight * 0.28;
  bounce.intensity = 0.09 + visualState.daylight * 0.2;

  moon.position.set(22 - Math.cos(arc) * 44, 10 + (1 - visualState.daylight) * 28, 20 - Math.sin(arc) * 36);
  moon.intensity = 0.08 + (1 - visualState.daylight) * 0.38;

  hemi.intensity = 0.28 + visualState.daylight * 0.54;
  tempColorA.lerpColors(visualColors.hemiSkyNight, visualColors.hemiSkyDay, visualState.daylight);
  hemi.color.copy(tempColorA);
  tempColorA.lerpColors(visualColors.hemiGroundNight, visualColors.hemiGroundDay, visualState.daylight);
  hemi.groundColor.copy(tempColorA);

  tempColorA.lerpColors(visualColors.sunDusk, visualColors.sunDay, visualState.daylight);
  sun.color.copy(tempColorA);

  tempColorA.lerpColors(visualColors.fogNight, visualColors.fogDay, visualState.daylight);
  tempColorB.copy(tempColorA).lerp(visualColors.fogDusk, visualState.rainStrength * 0.2);
  scene.fog.color.copy(tempColorB);
  const fogScale = environment.fogDensityScale || 1;
  scene.fog.near = (58 + visualState.daylight * 20) * fogScale;
  scene.fog.far = (230 + visualState.daylight * 190 - visualState.rainStrength * 64) * fogScale;

  renderer.toneMappingExposure = BASE_EXPOSURE + visualState.daylight * 0.26 - visualState.rainStrength * 0.1;

  if (environment.sunDisk) {
    environment.sunDisk.position.set(sun.position.x * 2.8, 56 + visualState.daylight * 42, -340 + Math.cos(arc * 0.5) * 20);
    environment.sunDisk.visible = visualState.daylight > 0.16;
  }
  if (environment.sunHalo) {
    environment.sunHalo.position.copy(environment.sunDisk.position);
    environment.sunHalo.material.opacity = 0.02 + visualState.daylight * 0.18;
    environment.sunHalo.visible = visualState.daylight > 0.16;
  }

  if (environment.moonDisk) {
    environment.moonDisk.position.set(
      moon.position.x * 3.5,
      62 + (1 - visualState.daylight) * 46,
      -360 + Math.sin(arc * 0.5 + Math.PI) * 20
    );
    environment.moonDisk.visible = visualState.daylight < 0.86;
  }
  if (environment.moonHalo) {
    environment.moonHalo.position.copy(environment.moonDisk.position);
    environment.moonHalo.material.opacity = 0.04 + (1 - visualState.daylight) * 0.2;
    environment.moonHalo.visible = visualState.daylight < 0.86;
  }
}

function updateRainSystem(rainSystem, dt) {
  const positions = rainSystem.positions;
  const activeCount = rainSystem.activeCount || rainSystem.count;
  const wind = visualState.windDrift * 0.8;
  const fallScale = 0.7 + visualState.rainStrength * 0.8;
  const travelZ = state.worldSpeed * dt * 0.3 + 1.6 * dt;
  const halfWidth = params.roadWidth * 0.5 + 16;

  for (let i = 0; i < activeCount; i += 1) {
    const index = i * 3;
    positions[index] += (rainSystem.drifts[i] + wind) * dt * 3.4;
    positions[index + 1] -= rainSystem.speeds[i] * dt * fallScale;
    positions[index + 2] += travelZ;

    if (
      positions[index + 1] < rainSystem.minY ||
      positions[index + 2] > rainSystem.maxZ ||
      Math.abs(positions[index]) > halfWidth
    ) {
      positions[index] = (Math.random() - 0.5) * halfWidth * 2;
      positions[index + 1] = rainSystem.maxY - Math.random() * 3;
      positions[index + 2] = rainSystem.minZ + Math.random() * (rainSystem.maxZ - rainSystem.minZ);
    }
  }

  rainSystem.geometry.setDrawRange(0, activeCount);
  rainSystem.geometry.attributes.position.needsUpdate = true;
  rainSystem.material.opacity = 0.12 + visualState.rainStrength * 0.4;
  rainSystem.material.size = 0.16 + visualState.rainStrength * 0.2;
}

function updateCamera(dt, nowSeconds) {
  const mobileView = window.innerWidth < 760;
  const basePos = mobileView ? cameraRig.mobilePosition : cameraRig.desktopPosition;
  const baseLook = mobileView ? cameraRig.mobileLookAt : cameraRig.desktopLookAt;
  const speedFactor = THREE.MathUtils.clamp((state.speedKmh - 190) / 190, 0, 1);

  const lateralLead = player.group.position.x * 0.24;
  const speedDrop = speedFactor * 0.34;
  const moving = state.running && !state.paused && !state.gameOver;
  const shakeAmp = moving ? 0.008 + speedFactor * 0.018 + visualState.rainStrength * 0.006 : 0;
  const shakeX = Math.sin(nowSeconds * 20.0) * shakeAmp;
  const shakeY = Math.cos(nowSeconds * 15.5) * shakeAmp * 0.8;

  cameraRig.positionTarget.set(
    basePos.x + lateralLead * 0.3 + shakeX,
    basePos.y + speedDrop + shakeY,
    basePos.z - speedFactor * 1.8
  );
  camera.position.lerp(cameraRig.positionTarget, Math.min(1, dt * 4.2));

  cameraRig.lookAtTarget.set(
    player.group.position.x * 0.31,
    baseLook.y + speedFactor * 0.2,
    baseLook.z - speedFactor * 1.3
  );
  camera.lookAt(cameraRig.lookAtTarget);

  const targetFov = (mobileView ? 57 : 56) + speedFactor * 4.2 + visualState.rainStrength * 1.0;
  camera.fov += (targetFov - camera.fov) * Math.min(1, dt * 2.6);
  camera.updateProjectionMatrix();
}

function updateEnvironment(dt, nowSeconds) {
  const dashRange = params.roadLength;
  const markerGlow = 0.24 + (1 - visualState.daylight) * 0.54 + visualState.rainStrength * 0.22;
  if (environment.instanceSystems) {
    updateInstancedRoadside(environment.instanceSystems, dt, nowSeconds, state.worldSpeed, params);
  }
  for (const dash of environment.dashes) {
    dash.position.z += state.worldSpeed * dt * 1.08;
    if (dash.position.z > dashRange * 0.5) {
      dash.position.z -= dashRange;
    }
  }

  for (const marker of environment.markers) {
    marker.position.z += state.worldSpeed * dt;
    if (marker.position.z > params.recycleZ + 18) {
      marker.position.z -= params.roadLength;
    }
  }

  for (const lamp of environment.lamps) {
    lamp.group.position.z += state.worldSpeed * dt * 0.96;
    if (lamp.group.position.z > params.recycleZ + 26) {
      lamp.group.position.z -= params.roadLength;
    }
    const lampBaseGlow = 0.28 + (1 - visualState.daylight) * 0.8 + visualState.rainStrength * 0.18;
    lamp.bulb.material.emissiveIntensity = lampBaseGlow + Math.sin(nowSeconds * 1.1 + lamp.phase) * 0.08;
  }

  if (environment.guardrails) {
    for (const rail of environment.guardrails) {
      rail.position.z += state.worldSpeed * dt;
      if (rail.position.z > params.recycleZ + 18) {
        rail.position.z -= params.roadLength;
      }
    }
  }

  if (environment.signboards) {
    for (const sign of environment.signboards) {
      sign.position.z += state.worldSpeed * dt * 0.98;
      if (sign.position.z > params.recycleZ + 20) {
        sign.position.z -= params.roadLength;
      }
    }
  }

  if (environment.trees) {
    for (const tree of environment.trees) {
      tree.group.position.z += state.worldSpeed * dt * tree.speed;
      if (tree.group.position.z > params.recycleZ + 40) {
        tree.group.position.z -= params.roadLength;
      }
      tree.group.rotation.z = Math.sin(nowSeconds * 0.8 + tree.phase) * tree.sway;
    }
  }

  if (environment.utilityPoles) {
    for (const pole of environment.utilityPoles) {
      pole.group.position.z += state.worldSpeed * dt * pole.speed;
      if (pole.group.position.z > params.recycleZ + 36) {
        pole.group.position.z -= params.roadLength;
      }
      pole.group.rotation.z = Math.sin(nowSeconds * 0.55 + pole.phase) * 0.004;
    }
  }

  if (environment.cloudLayers) {
    for (const cloud of environment.cloudLayers) {
      cloud.mesh.position.x = cloud.baseX + Math.sin(nowSeconds * cloud.drift + cloud.phase) * cloud.driftWidth;
      cloud.mesh.position.z = cloud.baseZ + Math.cos(nowSeconds * (cloud.drift * 0.45) + cloud.phase) * cloud.zDrift;
      cloud.mesh.material.opacity = (0.08 + visualState.rainStrength * 0.16) * cloud.opacityScale;
    }
  }

  if (environment.mistLayers) {
    for (const mist of environment.mistLayers) {
      mist.mesh.position.z += state.worldSpeed * dt * mist.speed;
      if (mist.mesh.position.z > params.recycleZ + 44) {
        mist.mesh.position.z -= params.roadLength + 80;
      }
      mist.mesh.position.x = mist.baseX + Math.sin(nowSeconds * 0.22 + mist.phase) * mist.drift;
      mist.mesh.material.opacity = (0.04 + visualState.rainStrength * 0.12) * mist.opacityScale;
    }
  }

  if (environment.rainSystem) {
    updateRainSystem(environment.rainSystem, dt);
  }

  if (environment.roadTexture) {
    environment.roadTexture.offset.y -= (state.worldSpeed * dt) / 220;
  }
  if (environment.roadBaseColorMap) {
    environment.roadBaseColorMap.offset.y -= (state.worldSpeed * dt) / 220;
  }
  if (environment.roadRoughnessMap) {
    environment.roadRoughnessMap.offset.y -= (state.worldSpeed * dt) / 220;
  }
  if (environment.roadNormalMap) {
    environment.roadNormalMap.offset.y -= (state.worldSpeed * dt) / 220;
  }
  if (environment.laneMarkingsTexture) {
    environment.laneMarkingsTexture.offset.y -= (state.worldSpeed * dt) / 220;
  }

  if (environment.roadSheenTexture) {
    environment.roadSheenTexture.offset.y -= (state.worldSpeed * dt) / 360;
  }

  if (environment.roadWearTexture) {
    environment.roadWearTexture.offset.y -= (state.worldSpeed * dt) / 280;
  }

  if (environment.groundTexture) {
    environment.groundTexture.offset.y -= (state.worldSpeed * dt) / 650;
  }
  if (environment.shoulderBlendTexture) {
    environment.shoulderBlendTexture.offset.y -= (state.worldSpeed * dt) / 320;
  }

  if (environment.roadMaterial) {
    environment.roadMaterial.roughness = 0.9 - visualState.wetness * 0.34;
    environment.roadMaterial.metalness = 0.08 + visualState.wetness * 0.12;
  }

  if (environment.roadSheenMaterial) {
    environment.roadSheenMaterial.opacity = 0.08 + visualState.wetness * 0.26;
    environment.roadSheenMaterial.roughness = 0.14 + (1 - visualState.wetness) * 0.2;
  }

  if (environment.roadWearMaterial) {
    environment.roadWearMaterial.opacity = 0.18 + visualState.wetness * 0.2;
  }

  if (environment.laneMarkingsMaterial) {
    environment.laneMarkingsMaterial.opacity = 0.74 - visualState.wetness * 0.2;
    environment.laneMarkingsMaterial.roughness = 0.62 - visualState.wetness * 0.08;
  }

  if (environment.roadReflectionMaterial) {
    environment.roadReflectionMaterial.opacity = 0.04 + visualState.wetness * 0.25;
    environment.roadReflectionMaterial.roughness = 0.08 + (1 - visualState.wetness) * 0.18;
    environment.roadReflectionMaterial.clearcoat = 0.36 + visualState.wetness * 0.48;
    environment.roadReflectionMaterial.clearcoatRoughness = 0.08 + (1 - visualState.wetness) * 0.24;
  }

  if (environment.markerReflectors) {
    for (const reflector of environment.markerReflectors) {
      reflector.material.emissiveIntensity = markerGlow;
    }
  }
}

function updateWorld(dt, elapsed, nowSeconds) {
  state.levelTimeLeft = Math.max(0, state.levelTimeLeft - dt);
  const levelTimeUse = 1 - state.levelTimeLeft / Math.max(1, state.levelTimeLimit);

  state.difficulty = 1 + elapsed * 0.04 + (state.level - 1) * 0.18 + levelTimeUse * 0.22;
  if (state.comboTimer > 0) {
    state.comboTimer = Math.max(0, state.comboTimer - dt);
  } else if (state.comboMultiplier !== 1 || state.comboCount !== 0) {
    state.comboMultiplier = 1;
    state.comboCount = 0;
  }

  state.boostTimer = Math.max(0, state.boostTimer - dt);
  const boostFactor = state.boostTimer > 0 ? 1.3 : 1;
  const baseSpeed = 25 + state.difficulty * 5.3;
  state.worldSpeed = baseSpeed * boostFactor;
  state.speedKmh = state.worldSpeed * 7.35;

  const scoreRate = 11.8 * state.difficulty * state.comboMultiplier * (state.boostTimer > 0 ? 1.25 : 1);
  state.score += dt * scoreRate;

  updateEnvironment(dt, nowSeconds);
  updateObstacles(dt, nowSeconds);
  if (!state.gameOver) {
    updateCollectibles(dt, nowSeconds);
  }

  if (state.gameOver) {
    updateEventTicker();
    return;
  }

  const levelProgress = getLevelProgress();
  if (levelProgress.score >= state.levelTargetScore && levelProgress.rewards >= state.levelTargetRewards) {
    const clearedLevel = state.level;
    const levelBonus = 140 + clearedLevel * 45 + Math.round(state.levelTimeLeft * 8);
    state.score += levelBonus;
    applyLevelGoal(clearedLevel + 1);
    pushEvent(
      `Level ${clearedLevel} clear +${levelBonus}. Level ${state.level} objectives online.`,
      "level",
      2.2
    );
  }

  if (state.levelTimeLeft <= 0) {
    endGame("timeout");
    return;
  }

  updateEventTicker();
}

if (startButton) startButton.addEventListener("click", startGame);
if (pauseButton) pauseButton.addEventListener("click", togglePause);
if (leftButton) leftButton.addEventListener("click", () => moveLane(-1));
if (rightButton) rightButton.addEventListener("click", () => moveLane(1));

window.addEventListener("keydown", (event) => {
  if (event.code === "ArrowLeft" || event.code === "KeyA") {
    event.preventDefault();
    moveLane(-1);
  }
  if (event.code === "ArrowRight" || event.code === "KeyD") {
    event.preventDefault();
    moveLane(1);
  }
  if (event.code === "Space" || event.code === "KeyO") {
    event.preventDefault();
    togglePause();
  }
  if (event.code === "KeyP") {
    event.preventDefault();
    exportFramePng();
  }
  if (event.code === "KeyR") {
    event.preventDefault();
    setDeterministicMode(!state.deterministicMode);
  }
  if (event.code === "Digit1") {
    event.preventDefault();
    setQualityLevel(1);
  }
  if (event.code === "Digit2") {
    event.preventDefault();
    setQualityLevel(2);
  }
  if (event.code === "Digit3") {
    event.preventDefault();
    setQualityLevel(3);
  }
  if (event.code === "KeyF") {
    event.preventDefault();
    toggleFullscreen();
  }
  if (event.code === "Enter" && (!state.running || state.gameOver)) {
    event.preventDefault();
    startGame();
  }
});

let touchStartX = 0;
let touchStartY = 0;
window.addEventListener(
  "touchstart",
  (event) => {
    const t = event.changedTouches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
  },
  { passive: true }
);

window.addEventListener(
  "touchend",
  (event) => {
    const t = event.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    if (Math.abs(dx) > 34 && Math.abs(dx) > Math.abs(dy)) {
      moveLane(dx > 0 ? 1 : -1);
    }
  },
  { passive: true }
);

function handleResize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const quality = qualityPresets[state.qualityLevel];
  camera.aspect = w / h;
  const mobileView = w < 760;
  const basePos = mobileView ? cameraRig.mobilePosition : cameraRig.desktopPosition;
  const baseLook = mobileView ? cameraRig.mobileLookAt : cameraRig.desktopLookAt;
  camera.position.copy(basePos);
  cameraRig.positionTarget.copy(basePos);
  cameraRig.lookAtTarget.copy(baseLook);
  camera.lookAt(baseLook);
  camera.fov = mobileView ? 57 : 56;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, quality.maxPixelRatio));
  if (postFx.composer) {
    postFx.composer.setSize(w, h);
  }
}

window.addEventListener("resize", handleResize);
document.addEventListener("fullscreenchange", handleResize);

document.addEventListener("visibilitychange", () => {
  if (document.hidden && state.running && !state.paused && !state.gameOver) {
    togglePause();
  }
});

let lastTime = performance.now();
function updateRuntimeFps(dt) {
  if (!Number.isFinite(dt) || dt <= 0) return;
  runtimeStats.fpsAccumulator += dt;
  runtimeStats.frameAccumulator += 1;
  if (runtimeStats.fpsAccumulator >= 0.4) {
    runtimeStats.fps = runtimeStats.frameAccumulator / runtimeStats.fpsAccumulator;
    runtimeStats.fpsAccumulator = 0;
    runtimeStats.frameAccumulator = 0;
    if (!state.running || state.paused || state.gameOver) {
      updateHud();
    }
  }
}

function renderFrame() {
  if (postFx.enabled && postFx.composer) {
    try {
      postFx.composer.render();
      return;
    } catch (err) {
      postFx.enabled = false;
      if (!postFxDisabledByError) {
        postFxDisabledByError = true;
        pushEvent("PostFX disabled for compatibility.", "danger", 2.2);
        console.warn("PostFX render failed; falling back to direct renderer.", err);
      }
    }
  }
  renderer.render(scene, camera);
}

function stepSimulation(dt) {
  simulationTimeMs += dt * 1000;
  const nowMs = simulationTimeMs;
  const nowSeconds = nowMs / 1000;
  updateAtmosphere(dt, nowSeconds);

  if (state.running && !state.paused && !state.gameOver) {
    const elapsed = (nowMs - state.startedAt) / 1000;
    updatePlayer(dt, nowMs);
    updateWorld(dt, elapsed, nowSeconds);
    updateHud();
  } else if (!state.running && !state.gameOver) {
    updatePlayer(dt, nowMs);
    updateEnvironment(dt * 0.2, nowSeconds);
    updateEventTicker();
  } else {
    updatePlayer(dt, nowMs);
    updateEventTicker();
  }

  updateCamera(dt, nowSeconds);
}

function frame(now) {
  const realDt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;
  updateRuntimeFps(realDt);
  const dt = state.deterministicMode ? 1 / 60 : realDt;
  stepSimulation(dt);
  renderFrame();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

window.advanceTime = (ms) => {
  const totalSteps = Math.max(1, Math.round(ms / (1000 / 60)));
  const dt = state.deterministicMode ? 1 / 60 : (ms / 1000) / totalSteps;
  for (let i = 0; i < totalSteps; i += 1) {
    stepSimulation(dt);
  }
  renderFrame();
};

function roundNumber(value, digits = 2) {
  const factor = 10 ** digits;
  return Math.round(value * factor) / factor;
}

function renderGameToText() {
  const mode = state.gameOver ? "game_over" : state.running ? (state.paused ? "paused" : "running") : "ready";
  const levelProgress = getLevelProgress();
  const sortedObstacles = [...state.obstacles].sort((a, b) => b.mesh.position.z - a.mesh.position.z).slice(0, 12);
  const sortedRewards = [...state.collectibles].sort((a, b) => b.mesh.position.z - a.mesh.position.z).slice(0, 10);

  const payload = {
    coordinateSystem: "x left(-)/right(+), z far(-)->near(+ toward player), y up(+)",
    mode,
    player: {
      laneIndex: state.laneIndex,
      x: roundNumber(player.group.position.x),
      y: roundNumber(player.group.position.y),
      z: params.playerZ,
      laneTargetX: roundNumber(state.laneTargetX)
    },
    stats: {
      score: Math.floor(state.score),
      best: Math.floor(state.bestScore),
      difficulty: roundNumber(state.difficulty, 2),
      level: state.level,
      speedKmh: Math.round(state.speedKmh),
      rewardsCollected: state.rewardsCollected,
      comboMultiplier: roundNumber(state.comboMultiplier, 2),
      boostSeconds: roundNumber(Math.max(0, state.boostTimer), 2),
      qualityLevel: state.qualityLevel,
      deterministicMode: state.deterministicMode,
      fps: roundNumber(runtimeStats.fps, 1),
      levelGoalScore: state.levelTargetScore,
      levelGoalRewards: state.levelTargetRewards,
      levelScoreProgress: Math.floor(levelProgress.score),
      levelRewardProgress: Math.floor(levelProgress.rewards),
      levelTimeLeft: roundNumber(Math.max(0, state.levelTimeLeft), 2),
      levelTimeLimit: roundNumber(state.levelTimeLimit, 2)
    },
    atmosphere: {
      daylight: roundNumber(visualState.daylight, 2),
      rainStrength: roundNumber(visualState.rainStrength, 2),
      wetness: roundNumber(visualState.wetness, 2),
      fogNear: roundNumber(scene.fog.near, 1),
      fogFar: roundNumber(scene.fog.far, 1)
    },
    obstacles: sortedObstacles.map((item) => ({
      type: item.type || "obstacle",
      x: roundNumber(item.mesh.position.x),
      z: roundNumber(item.mesh.position.z),
      width: roundNumber(item.width),
      depth: roundNumber(item.depth)
    })),
    rewards: sortedRewards.map((item) => ({
      type: item.type,
      x: roundNumber(item.mesh.position.x),
      z: roundNumber(item.mesh.position.z),
      width: roundNumber(item.width),
      depth: roundNumber(item.depth)
    }))
  };

  return JSON.stringify(payload);
}

window.render_game_to_text = renderGameToText;

applyQualityPreset(qualityPresets[state.qualityLevel], environment, renderer, postFx, sun);
handleResize();
loadOptionalRoadAssets(environment, renderer).then((loaded) => {
  if (loaded) {
    pushEvent("External asphalt PBR textures loaded.", "level", 1.6);
  }
});
updateHud();
setStatus("Press Start. Clear each level goal before timer expires. Keys: 1/2/3 quality, R deterministic, P PNG.");
if (postFx.failed) {
  pushEvent("PostFX unavailable. Compatibility mode enabled.", "danger", 2.3);
}

function disposeObject3D(root) {
  root.traverse((child) => {
    if (!child.isMesh) return;
    if (child.geometry) child.geometry.dispose();
    if (Array.isArray(child.material)) {
      for (const mat of child.material) mat.dispose();
    } else if (child.material) {
      child.material.dispose();
    }
  });
}

function createSeededRng(seed) {
  let value = seed >>> 0;
  return () => {
    value = (value * 1664525 + 1013904223) >>> 0;
    return value / 4294967296;
  };
}

function withSeededRandom(seed, callback) {
  const previousRandom = Math.random;
  const seeded = createSeededRng(seed);
  Math.random = () => seeded();
  try {
    return callback();
  } finally {
    Math.random = previousRandom;
  }
}

function initRenderer(container) {
  const rendererRef = new THREE.WebGLRenderer({
    antialias: true,
    powerPreference: "high-performance"
  });
  rendererRef.outputColorSpace = THREE.SRGBColorSpace;
  rendererRef.toneMapping = THREE.ACESFilmicToneMapping;
  rendererRef.toneMappingExposure = BASE_EXPOSURE;
  if ("useLegacyLights" in rendererRef) {
    rendererRef.useLegacyLights = false;
  }
  if ("physicallyCorrectLights" in rendererRef) {
    rendererRef.physicallyCorrectLights = true;
  }
  rendererRef.shadowMap.enabled = true;
  rendererRef.shadowMap.type = THREE.PCFSoftShadowMap;
  rendererRef.setPixelRatio(Math.min(window.devicePixelRatio, qualityPresets[DEFAULT_QUALITY_LEVEL].maxPixelRatio));
  rendererRef.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(rendererRef.domElement);
  return rendererRef;
}

function initLighting(sceneRef, rendererRef, fallbackSkyTexture) {
  const hemi = new THREE.HemisphereLight(0xe8f2ff, 0x43503d, 0.72);
  sceneRef.add(hemi);

  const sun = new THREE.DirectionalLight(0xfff4dd, 1.2);
  sun.position.set(-24, 34, -8);
  sun.castShadow = true;
  sun.shadow.mapSize.set(qualityPresets[DEFAULT_QUALITY_LEVEL].shadowMapSize, qualityPresets[DEFAULT_QUALITY_LEVEL].shadowMapSize);
  sun.shadow.camera.left = -56;
  sun.shadow.camera.right = 56;
  sun.shadow.camera.top = 56;
  sun.shadow.camera.bottom = -56;
  sun.shadow.camera.near = 1;
  sun.shadow.camera.far = 140;
  sun.shadow.bias = -0.00007;
  sceneRef.add(sun);

  const fill = new THREE.DirectionalLight(0xc4daf9, 0.34);
  fill.position.set(20, 13, 26);
  sceneRef.add(fill);

  const bounce = new THREE.DirectionalLight(0xa2c3ee, 0.16);
  bounce.position.set(0, 8, 34);
  sceneRef.add(bounce);

  const moon = new THREE.DirectionalLight(0x98b5ff, 0.16);
  moon.position.set(24, 26, 8);
  sceneRef.add(moon);

  const pmrem = new THREE.PMREMGenerator(rendererRef);
  pmrem.compileEquirectangularShader();
  fallbackSkyTexture.mapping = THREE.EquirectangularReflectionMapping;
  const fallbackEnvMap = pmrem.fromEquirectangular(fallbackSkyTexture).texture;
  sceneRef.environment = fallbackEnvMap;

  const hdriCandidates = ["./assets/sky.hdr", "./assets/environment.hdr", "./assets/studio.hdr"];
  const rgbeLoader = new RGBELoader();
  const tryLoadHdri = (index = 0) => {
    if (index >= hdriCandidates.length) return;
    rgbeLoader.load(
      hdriCandidates[index],
      (hdrTexture) => {
        const envMap = pmrem.fromEquirectangular(hdrTexture).texture;
        sceneRef.environment = envMap;
        hdrTexture.dispose();
      },
      undefined,
      () => {
        tryLoadHdri(index + 1);
      }
    );
  };
  tryLoadHdri();

  return { hemi, sun, fill, bounce, moon };
}

function initPostFX(rendererRef, sceneRef, cameraRef) {
  try {
    const composer = new EffectComposer(rendererRef);
    composer.setSize(window.innerWidth, window.innerHeight);

    const renderPass = new RenderPass(sceneRef, cameraRef);
    composer.addPass(renderPass);

    const ssaoPass = new SSAOPass(sceneRef, cameraRef, window.innerWidth, window.innerHeight);
    ssaoPass.kernelRadius = 4;
    ssaoPass.minDistance = 0.003;
    ssaoPass.maxDistance = 0.08;
    composer.addPass(ssaoPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      qualityPresets[DEFAULT_QUALITY_LEVEL].bloomStrength,
      0.5,
      qualityPresets[DEFAULT_QUALITY_LEVEL].bloomThreshold
    );
    composer.addPass(bloomPass);

    return {
      enabled: true,
      composer,
      renderPass,
      ssaoPass,
      bloomPass,
      failed: false
    };
  } catch (err) {
    console.warn("PostFX initialization failed; continuing without post processing.", err);
    return {
      enabled: false,
      composer: null,
      renderPass: null,
      ssaoPass: null,
      bloomPass: null,
      failed: true
    };
  }
}

function applyInstanceDensity(instanceSystems, density) {
  if (!instanceSystems) return;
  for (const key of Object.keys(instanceSystems)) {
    const system = instanceSystems[key];
    if (!system || typeof system.setDensity !== "function") continue;
    system.setDensity(density);
  }
}

function applyQualityPreset(preset, environmentRef, rendererRef, postFxRef, sunLight) {
  rendererRef.setPixelRatio(Math.min(window.devicePixelRatio, preset.maxPixelRatio));
  rendererRef.shadowMap.enabled = true;
  sunLight.shadow.mapSize.set(preset.shadowMapSize, preset.shadowMapSize);
  if (sunLight.shadow.map) {
    sunLight.shadow.map.dispose();
    sunLight.shadow.map = null;
  }
  sunLight.shadow.needsUpdate = true;

  const hasPostFx = Boolean(postFxRef && postFxRef.composer && postFxRef.ssaoPass && postFxRef.bloomPass);
  if (hasPostFx) {
    postFxRef.enabled = preset.aoEnabled || preset.bloomEnabled;
    postFxRef.ssaoPass.enabled = preset.aoEnabled;
    postFxRef.ssaoPass.kernelRadius = preset.aoRadius;
    postFxRef.bloomPass.enabled = preset.bloomEnabled;
    postFxRef.bloomPass.strength = preset.bloomStrength;
    postFxRef.bloomPass.threshold = preset.bloomThreshold;
  } else {
    postFxRef.enabled = false;
  }

  environmentRef.fogDensityScale = preset.fogDensityScale;
  applyInstanceDensity(environmentRef.instanceSystems, preset.instanceDensity);
  if (environmentRef.rainSystem) {
    environmentRef.rainSystem.activeCount = Math.max(
      220,
      Math.floor(environmentRef.rainSystem.count * (0.56 + preset.instanceDensity * 0.44))
    );
  }
}

function createSkyTexture() {
  const canvas = document.createElement("canvas");
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext("2d");

  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0.0, "#78a7da");
  gradient.addColorStop(0.24, "#99bfe6");
  gradient.addColorStop(0.49, "#d5e5f6");
  gradient.addColorStop(0.64, "#f6dcc0");
  gradient.addColorStop(0.78, "#96abc1");
  gradient.addColorStop(1.0, "#51657f");

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const haze = ctx.createLinearGradient(0, canvas.height * 0.48, 0, canvas.height);
  haze.addColorStop(0.0, "rgba(255, 236, 212, 0.46)");
  haze.addColorStop(0.55, "rgba(217, 227, 240, 0.18)");
  haze.addColorStop(1.0, "rgba(139, 161, 189, 0.06)");
  ctx.fillStyle = haze;
  ctx.fillRect(0, canvas.height * 0.46, canvas.width, canvas.height * 0.54);

  for (let i = 0; i < 240; i += 1) {
    const x = Math.random() * canvas.width;
    const y = 140 + Math.random() * 440;
    const radiusX = 40 + Math.random() * 190;
    const radiusY = 14 + Math.random() * 48;
    const alpha = y < 320 ? 0.018 + Math.random() * 0.03 : 0.03 + Math.random() * 0.06;
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.beginPath();
    ctx.ellipse(x, y, radiusX, radiusY, Math.random() * Math.PI, 0, Math.PI * 2);
    ctx.fill();
  }

  const glow = ctx.createRadialGradient(
    canvas.width * 0.23,
    canvas.height * 0.53,
    6,
    canvas.width * 0.23,
    canvas.height * 0.53,
    250
  );
  glow.addColorStop(0.0, "rgba(255, 250, 232, 0.78)");
  glow.addColorStop(0.42, "rgba(255, 225, 186, 0.3)");
  glow.addColorStop(1.0, "rgba(255, 225, 186, 0)");
  ctx.fillStyle = glow;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 140; i += 1) {
    const y = 560 + Math.random() * 360;
    const alpha = 0.02 + Math.random() * 0.035;
    const h = 1 + Math.random() * 3;
    ctx.fillStyle = `rgba(206, 223, 243, ${alpha})`;
    ctx.fillRect(0, y, canvas.width, h);
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.minFilter = THREE.LinearMipmapLinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.generateMipmaps = true;
  return texture;
}

function createGroundTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 1024;
  canvas.height = 1024;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "#5f6f54";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 14000; i += 1) {
    const warm = 74 + Math.floor(Math.random() * 44);
    const cool = 84 + Math.floor(Math.random() * 42);
    const alpha = 0.03 + Math.random() * 0.07;
    ctx.fillStyle = `rgba(${warm}, ${cool}, ${warm - 18}, ${alpha})`;
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const size = 1 + Math.random() * 4;
    ctx.fillRect(x, y, size, size);
  }

  for (let i = 0; i < 56; i += 1) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const radiusX = 18 + Math.random() * 70;
    const radiusY = 12 + Math.random() * 36;
    const alpha = 0.05 + Math.random() * 0.1;
    ctx.fillStyle = `rgba(92, 80, 61, ${alpha})`;
    ctx.beginPath();
    ctx.ellipse(x, y, radiusX, radiusY, Math.random() * Math.PI, 0, Math.PI * 2);
    ctx.fill();
  }

  for (let i = 0; i < 220; i += 1) {
    const y = Math.random() * canvas.height;
    const alpha = 0.01 + Math.random() * 0.03;
    const h = 1 + Math.random() * 2;
    ctx.fillStyle = `rgba(172, 186, 158, ${alpha})`;
    ctx.fillRect(0, y, canvas.width, h);
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(14, 24);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = Math.min(8, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function createShoulderTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 1024;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "#70757a";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 9000; i += 1) {
    const tone = 96 + Math.floor(Math.random() * 64);
    const alpha = 0.06 + Math.random() * 0.16;
    ctx.fillStyle = `rgba(${tone}, ${tone}, ${tone}, ${alpha})`;
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const w = 1 + Math.random() * 2.8;
    const h = 1 + Math.random() * 2.8;
    ctx.fillRect(x, y, w, h);
  }

  ctx.strokeStyle = "rgba(55, 59, 66, 0.34)";
  ctx.lineWidth = 1.2;
  for (let i = 0; i < 28; i += 1) {
    const x1 = Math.random() * canvas.width;
    const x2 = x1 + (Math.random() - 0.5) * 80;
    const y1 = Math.random() * canvas.height;
    const y2 = y1 + 70 + Math.random() * 170;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(1, 12);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = Math.min(8, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function createAsphaltTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 1024;
  canvas.height = 2048;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "#2f3439";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 18000; i += 1) {
    const tone = 42 + Math.floor(Math.random() * 48);
    const alpha = 0.04 + Math.random() * 0.12;
    ctx.fillStyle = `rgba(${tone}, ${tone}, ${tone + 4}, ${alpha})`;
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const s = 1 + Math.random() * 3;
    ctx.fillRect(x, y, s, s);
  }

  ctx.strokeStyle = "rgba(198, 203, 210, 0.03)";
  ctx.lineWidth = 2.1;
  for (let i = 0; i < 38; i += 1) {
    const x1 = Math.random() * canvas.width;
    const x2 = x1 + (Math.random() - 0.5) * 160;
    const y1 = Math.random() * canvas.height;
    const y2 = y1 + 140 + Math.random() * 320;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  for (const x of [canvas.width * 0.31, canvas.width * 0.69]) {
    const track = ctx.createLinearGradient(x, 0, x, canvas.height);
    track.addColorStop(0.0, "rgba(26, 29, 34, 0.08)");
    track.addColorStop(0.5, "rgba(22, 24, 30, 0.16)");
    track.addColorStop(1.0, "rgba(26, 29, 34, 0.08)");
    ctx.fillStyle = track;
    ctx.fillRect(x - 54, 0, 108, canvas.height);
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(1, 8);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = Math.min(8, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function createRoadSheenTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 1024;
  const ctx = canvas.getContext("2d");

  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0.0, "rgba(214, 226, 240, 0.22)");
  gradient.addColorStop(0.18, "rgba(214, 226, 240, 0.1)");
  gradient.addColorStop(0.6, "rgba(255, 255, 255, 0)");
  gradient.addColorStop(1.0, "rgba(132, 156, 184, 0.18)");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 180; i += 1) {
    const alpha = 0.02 + Math.random() * 0.045;
    const width = 14 + Math.random() * 48;
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.fillRect(x, y, width, 1 + Math.random() * 2.2);
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(1, 7);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = Math.min(8, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function createRoadWearTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 256;
  canvas.height = 1024;
  const ctx = canvas.getContext("2d");

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const x of [78, 178]) {
    const stain = ctx.createLinearGradient(x, 0, x, canvas.height);
    stain.addColorStop(0.0, "rgba(22, 24, 29, 0.18)");
    stain.addColorStop(0.5, "rgba(16, 18, 21, 0.34)");
    stain.addColorStop(1.0, "rgba(22, 24, 29, 0.18)");
    ctx.fillStyle = stain;
    ctx.fillRect(x - 24, 0, 48, canvas.height);
  }

  for (let i = 0; i < 1200; i += 1) {
    const alpha = 0.02 + Math.random() * 0.06;
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const r = 0.4 + Math.random() * 2.2;
    ctx.fillStyle = `rgba(32, 36, 42, ${alpha})`;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(1, 7);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = Math.min(8, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function createMistTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 256;
  const ctx = canvas.getContext("2d");

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0.0, "rgba(255, 255, 255, 0)");
  gradient.addColorStop(0.2, "rgba(229, 239, 252, 0.36)");
  gradient.addColorStop(0.7, "rgba(196, 216, 239, 0.3)");
  gradient.addColorStop(1.0, "rgba(255, 255, 255, 0)");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 46; i += 1) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const radiusX = 22 + Math.random() * 96;
    const radiusY = 9 + Math.random() * 28;
    const alpha = 0.06 + Math.random() * 0.14;
    ctx.fillStyle = `rgba(230, 240, 251, ${alpha})`;
    ctx.beginPath();
    ctx.ellipse(x, y, radiusX, radiusY, Math.random() * Math.PI, 0, Math.PI * 2);
    ctx.fill();
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = Math.min(4, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function createRainDropTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext("2d");

  const gradient = ctx.createLinearGradient(32, 0, 32, 64);
  gradient.addColorStop(0.0, "rgba(232, 243, 255, 0)");
  gradient.addColorStop(0.2, "rgba(232, 243, 255, 0.5)");
  gradient.addColorStop(0.8, "rgba(196, 224, 255, 0.95)");
  gradient.addColorStop(1.0, "rgba(232, 243, 255, 0)");
  ctx.fillStyle = gradient;
  ctx.fillRect(28, 0, 8, 64);

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = Math.min(2, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function createCloudTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 256;
  const ctx = canvas.getContext("2d");

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let i = 0; i < 56; i += 1) {
    const x = 28 + Math.random() * (canvas.width - 56);
    const y = 20 + Math.random() * (canvas.height - 40);
    const radiusX = 20 + Math.random() * 64;
    const radiusY = 10 + Math.random() * 24;
    const alpha = 0.07 + Math.random() * 0.14;
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.beginPath();
    ctx.ellipse(x, y, radiusX, radiusY, Math.random() * Math.PI, 0, Math.PI * 2);
    ctx.fill();
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = Math.min(4, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function configureTextureSampling(texture, rendererRef, options = {}) {
  const {
    repeatX = 1,
    repeatY = 1,
    colorSpace = null,
    maxAnisotropy = 8
  } = options;
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(repeatX, repeatY);
  if (colorSpace) {
    texture.colorSpace = colorSpace;
  }
  texture.anisotropy = Math.min(maxAnisotropy, rendererRef.capabilities.getMaxAnisotropy());
  return texture;
}

function createLaneMarkingsTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 1024;
  canvas.height = 2048;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const drawDivider = (x) => {
    const dashLength = 88;
    const gap = 70;
    for (let y = -dashLength; y < canvas.height + dashLength; y += dashLength + gap) {
      if (Math.random() < 0.1) continue;
      const width = 10 + Math.random() * 8;
      const alpha = 0.44 + Math.random() * 0.34;
      const jitterX = (Math.random() - 0.5) * 8;
      const jitterY = (Math.random() - 0.5) * 16;
      ctx.fillStyle = `rgba(246, 236, 212, ${alpha})`;
      ctx.fillRect(x + jitterX - width * 0.5, y + jitterY, width, dashLength + Math.random() * 12);
    }
  };

  const drawEdge = (x) => {
    for (let y = -40; y < canvas.height + 40; y += 82) {
      const width = 11 + Math.random() * 6;
      const alpha = 0.4 + Math.random() * 0.28;
      const jitter = (Math.random() - 0.5) * 4;
      ctx.fillStyle = `rgba(238, 230, 208, ${alpha})`;
      ctx.fillRect(x + jitter - width * 0.5, y, width, 96 + Math.random() * 16);
    }
  };

  drawDivider(canvas.width * 0.36);
  drawDivider(canvas.width * 0.64);
  drawEdge(canvas.width * 0.05);
  drawEdge(canvas.width * 0.95);

  ctx.globalCompositeOperation = "destination-out";
  for (let i = 0; i < 2200; i += 1) {
    const rx = 1 + Math.random() * 6;
    const ry = 1 + Math.random() * 7;
    ctx.fillStyle = `rgba(0, 0, 0, ${0.06 + Math.random() * 0.24})`;
    ctx.beginPath();
    ctx.ellipse(
      Math.random() * canvas.width,
      Math.random() * canvas.height,
      rx,
      ry,
      Math.random() * Math.PI,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  ctx.globalCompositeOperation = "source-over";
  for (let i = 0; i < 900; i += 1) {
    ctx.fillStyle = `rgba(92, 94, 92, ${0.02 + Math.random() * 0.06})`;
    const w = 3 + Math.random() * 16;
    const h = 1 + Math.random() * 7;
    ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, w, h);
  }

  const texture = new THREE.CanvasTexture(canvas);
  configureTextureSampling(texture, rendererRef, {
    repeatX: 1,
    repeatY: 8,
    colorSpace: THREE.SRGBColorSpace,
    maxAnisotropy: 8
  });
  return texture;
}

function createAsphaltPbrMaps(rendererRef) {
  const width = 1024;
  const height = 2048;
  const heightCanvas = document.createElement("canvas");
  heightCanvas.width = width;
  heightCanvas.height = height;
  const heightCtx = heightCanvas.getContext("2d");

  heightCtx.fillStyle = "#7a7a7a";
  heightCtx.fillRect(0, 0, width, height);

  for (let i = 0; i < 32000; i += 1) {
    const tone = 90 + Math.floor(Math.random() * 70);
    heightCtx.fillStyle = `rgba(${tone}, ${tone}, ${tone}, ${0.06 + Math.random() * 0.15})`;
    const size = 1 + Math.random() * 3;
    heightCtx.fillRect(Math.random() * width, Math.random() * height, size, size);
  }

  for (let i = 0; i < 46; i += 1) {
    const x = Math.random() * width;
    const y = Math.random() * height;
    const rx = 20 + Math.random() * 120;
    const ry = 8 + Math.random() * 50;
    const tone = 80 + Math.floor(Math.random() * 30);
    heightCtx.fillStyle = `rgba(${tone}, ${tone}, ${tone}, ${0.08 + Math.random() * 0.2})`;
    heightCtx.beginPath();
    heightCtx.ellipse(x, y, rx, ry, Math.random() * Math.PI, 0, Math.PI * 2);
    heightCtx.fill();
  }

  heightCtx.strokeStyle = "rgba(66, 66, 66, 0.32)";
  heightCtx.lineWidth = 1.2;
  for (let i = 0; i < 82; i += 1) {
    const x1 = Math.random() * width;
    const y1 = Math.random() * height;
    const x2 = x1 + (Math.random() - 0.5) * 180;
    const y2 = y1 + 90 + Math.random() * 260;
    heightCtx.beginPath();
    heightCtx.moveTo(x1, y1);
    heightCtx.lineTo(x2, y2);
    heightCtx.stroke();
  }

  for (const laneTrackX of [width * 0.31, width * 0.69]) {
    const trackGradient = heightCtx.createLinearGradient(laneTrackX, 0, laneTrackX, height);
    trackGradient.addColorStop(0.0, "rgba(80, 80, 80, 0.02)");
    trackGradient.addColorStop(0.5, "rgba(58, 58, 58, 0.15)");
    trackGradient.addColorStop(1.0, "rgba(80, 80, 80, 0.02)");
    heightCtx.fillStyle = trackGradient;
    heightCtx.fillRect(laneTrackX - 54, 0, 108, height);
  }

  const heightData = heightCtx.getImageData(0, 0, width, height);
  const sampleHeight = (x, y) => {
    const sx = Math.max(0, Math.min(width - 1, x));
    const sy = Math.max(0, Math.min(height - 1, y));
    return heightData.data[(sy * width + sx) * 4] / 255;
  };

  const baseCanvas = document.createElement("canvas");
  baseCanvas.width = width;
  baseCanvas.height = height;
  const baseCtx = baseCanvas.getContext("2d");
  const baseImage = baseCtx.createImageData(width, height);

  const roughCanvas = document.createElement("canvas");
  roughCanvas.width = width;
  roughCanvas.height = height;
  const roughCtx = roughCanvas.getContext("2d");
  const roughImage = roughCtx.createImageData(width, height);

  const normalCanvas = document.createElement("canvas");
  normalCanvas.width = width;
  normalCanvas.height = height;
  const normalCtx = normalCanvas.getContext("2d");
  const normalImage = normalCtx.createImageData(width, height);

  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const index = (y * width + x) * 4;
      const h = sampleHeight(x, y);
      const grain = (((x * 13 + y * 17) % 37) / 37 - 0.5) * 0.14;

      const r = Math.max(0, Math.min(255, Math.floor(42 + h * 40 + grain * 34)));
      const g = Math.max(0, Math.min(255, Math.floor(45 + h * 34 + grain * 28)));
      const b = Math.max(0, Math.min(255, Math.floor(49 + h * 30 + grain * 22)));

      baseImage.data[index] = r;
      baseImage.data[index + 1] = g;
      baseImage.data[index + 2] = b;
      baseImage.data[index + 3] = 255;

      const rough = Math.max(0, Math.min(255, Math.floor(186 + (1 - h) * 44 + grain * 40)));
      roughImage.data[index] = rough;
      roughImage.data[index + 1] = rough;
      roughImage.data[index + 2] = rough;
      roughImage.data[index + 3] = 255;

      const dx = sampleHeight(x + 1, y) - sampleHeight(x - 1, y);
      const dy = sampleHeight(x, y + 1) - sampleHeight(x, y - 1);
      const nx = -dx * 2.8;
      const ny = -dy * 2.8;
      const nz = 1;
      const invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);

      normalImage.data[index] = Math.floor((nx * invLen * 0.5 + 0.5) * 255);
      normalImage.data[index + 1] = Math.floor((ny * invLen * 0.5 + 0.5) * 255);
      normalImage.data[index + 2] = Math.floor((nz * invLen * 0.5 + 0.5) * 255);
      normalImage.data[index + 3] = 255;
    }
  }

  baseCtx.putImageData(baseImage, 0, 0);
  roughCtx.putImageData(roughImage, 0, 0);
  normalCtx.putImageData(normalImage, 0, 0);

  const baseColorMap = new THREE.CanvasTexture(baseCanvas);
  configureTextureSampling(baseColorMap, rendererRef, {
    repeatX: 1,
    repeatY: 8,
    colorSpace: THREE.SRGBColorSpace,
    maxAnisotropy: 8
  });

  const roughnessMap = new THREE.CanvasTexture(roughCanvas);
  configureTextureSampling(roughnessMap, rendererRef, {
    repeatX: 1,
    repeatY: 8,
    maxAnisotropy: 8
  });

  const normalMap = new THREE.CanvasTexture(normalCanvas);
  configureTextureSampling(normalMap, rendererRef, {
    repeatX: 1,
    repeatY: 8,
    maxAnisotropy: 8
  });

  return { baseColorMap, roughnessMap, normalMap };
}

function createShoulderBlendTexture(rendererRef) {
  const canvas = document.createElement("canvas");
  canvas.width = 256;
  canvas.height = 1024;
  const ctx = canvas.getContext("2d");
  const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
  gradient.addColorStop(0.0, "rgba(118, 109, 93, 0.74)");
  gradient.addColorStop(0.45, "rgba(104, 99, 87, 0.5)");
  gradient.addColorStop(1.0, "rgba(95, 120, 86, 0.18)");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 3600; i += 1) {
    const tone = 86 + Math.floor(Math.random() * 74);
    ctx.fillStyle = `rgba(${tone}, ${tone - 8}, ${tone - 18}, ${0.05 + Math.random() * 0.14})`;
    const size = 1 + Math.random() * 3;
    ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, size, size);
  }

  const texture = new THREE.CanvasTexture(canvas);
  configureTextureSampling(texture, rendererRef, {
    repeatX: 1,
    repeatY: 8,
    colorSpace: THREE.SRGBColorSpace,
    maxAnisotropy: 6
  });
  return texture;
}

function createGuardrailWearTextures(rendererRef) {
  const baseCanvas = document.createElement("canvas");
  baseCanvas.width = 512;
  baseCanvas.height = 512;
  const baseCtx = baseCanvas.getContext("2d");
  baseCtx.fillStyle = "#a2adba";
  baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

  for (let i = 0; i < 1500; i += 1) {
    const tone = 118 + Math.floor(Math.random() * 80);
    baseCtx.fillStyle = `rgba(${tone}, ${tone + 3}, ${tone + 10}, ${0.05 + Math.random() * 0.16})`;
    const radius = 1 + Math.random() * 4;
    baseCtx.beginPath();
    baseCtx.arc(Math.random() * baseCanvas.width, Math.random() * baseCanvas.height, radius, 0, Math.PI * 2);
    baseCtx.fill();
  }

  for (let i = 0; i < 220; i += 1) {
    baseCtx.fillStyle = `rgba(150, 108, 78, ${0.06 + Math.random() * 0.18})`;
    const w = 2 + Math.random() * 16;
    const h = 1 + Math.random() * 9;
    baseCtx.fillRect(Math.random() * baseCanvas.width, Math.random() * baseCanvas.height, w, h);
  }

  const roughCanvas = document.createElement("canvas");
  roughCanvas.width = baseCanvas.width;
  roughCanvas.height = baseCanvas.height;
  const roughCtx = roughCanvas.getContext("2d");
  roughCtx.fillStyle = "rgb(150, 150, 150)";
  roughCtx.fillRect(0, 0, roughCanvas.width, roughCanvas.height);

  for (let i = 0; i < 2600; i += 1) {
    const value = 118 + Math.floor(Math.random() * 124);
    roughCtx.fillStyle = `rgba(${value}, ${value}, ${value}, ${0.05 + Math.random() * 0.12})`;
    const size = 1 + Math.random() * 3;
    roughCtx.fillRect(Math.random() * roughCanvas.width, Math.random() * roughCanvas.height, size, size);
  }

  const baseColorMap = new THREE.CanvasTexture(baseCanvas);
  configureTextureSampling(baseColorMap, rendererRef, {
    repeatX: 6,
    repeatY: 1,
    colorSpace: THREE.SRGBColorSpace,
    maxAnisotropy: 6
  });

  const roughnessMap = new THREE.CanvasTexture(roughCanvas);
  configureTextureSampling(roughnessMap, rendererRef, {
    repeatX: 6,
    repeatY: 1,
    maxAnisotropy: 6
  });

  return { baseColorMap, roughnessMap };
}

function buildInstances(world, config, qualityPreset, guardrailTextures) {
  const systems = {};
  const railEntries = [];
  for (let z = -config.roadLength * 0.5; z < config.roadLength * 0.5; z += 10.5) {
    for (const side of [-1, 1]) {
      railEntries.push({ x: side * (config.roadWidth * 0.5 + 2.25), z, speed: 1 });
    }
  }

  const railMat = new THREE.MeshStandardMaterial({
    map: guardrailTextures.baseColorMap,
    roughnessMap: guardrailTextures.roughnessMap,
    color: 0xb6c0cd,
    roughness: 0.52,
    metalness: 0.78
  });
  const railPostMat = new THREE.MeshStandardMaterial({ color: 0x737d88, roughness: 0.72, metalness: 0.34 });
  const beamLowMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(3.25, 0.12, 0.18), railMat, railEntries.length);
  const beamHighMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(3.25, 0.12, 0.18), railMat, railEntries.length);
  const postMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(0.12, 0.9, 0.12), railPostMat, railEntries.length * 3);
  for (const mesh of [beamLowMesh, beamHighMesh, postMesh]) {
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    world.add(mesh);
  }

  const railDummy = new THREE.Object3D();
  const postOffsets = [-1.4, 0, 1.4];
  systems.guardrails = {
    entries: railEntries,
    activeCount: railEntries.length,
    setDensity(density) {
      this.activeCount = Math.max(4, Math.floor(railEntries.length * density));
      beamLowMesh.count = this.activeCount;
      beamHighMesh.count = this.activeCount;
      postMesh.count = this.activeCount * 3;
    },
    update(dt, worldSpeed, recycleZ, roadLength) {
      for (let i = 0; i < this.activeCount; i += 1) {
        const entry = railEntries[i];
        entry.z += worldSpeed * dt * entry.speed;
        if (entry.z > recycleZ + 18) {
          entry.z -= roadLength;
        }

        railDummy.position.set(entry.x, 0.62, entry.z);
        railDummy.rotation.set(0, 0, 0);
        railDummy.scale.set(1, 1, 1);
        railDummy.updateMatrix();
        beamLowMesh.setMatrixAt(i, railDummy.matrix);

        railDummy.position.set(entry.x, 0.88, entry.z);
        railDummy.updateMatrix();
        beamHighMesh.setMatrixAt(i, railDummy.matrix);

        for (let p = 0; p < postOffsets.length; p += 1) {
          railDummy.position.set(entry.x + postOffsets[p], 0.45, entry.z);
          railDummy.updateMatrix();
          postMesh.setMatrixAt(i * postOffsets.length + p, railDummy.matrix);
        }
      }
      beamLowMesh.instanceMatrix.needsUpdate = true;
      beamHighMesh.instanceMatrix.needsUpdate = true;
      postMesh.instanceMatrix.needsUpdate = true;
    }
  };
  systems.guardrails.setDensity(qualityPreset.instanceDensity);
  systems.guardrails.update(0, 0, config.recycleZ, config.roadLength);

  const lampEntries = [];
  for (let z = -config.roadLength * 0.5; z < config.roadLength * 0.5; z += 30) {
    for (const side of [-1, 1]) {
      lampEntries.push({
        x: side * (config.roadWidth * 0.5 + 3.35),
        z,
        side,
        speed: 0.96,
        phase: Math.random() * Math.PI * 2
      });
    }
  }

  const lampPoleMat = new THREE.MeshStandardMaterial({ color: 0x616872, roughness: 0.78, metalness: 0.24 });
  const lampArmMat = new THREE.MeshStandardMaterial({ color: 0x6b737c, roughness: 0.7, metalness: 0.22 });
  const lampFixtureMat = new THREE.MeshStandardMaterial({ color: 0x3e434b, roughness: 0.62, metalness: 0.22 });
  const lampBulbMat = new THREE.MeshStandardMaterial({
    color: 0xffefcc,
    emissive: 0xffce84,
    emissiveIntensity: 0.58,
    roughness: 0.42,
    metalness: 0.06
  });
  const lampPoleMesh = new THREE.InstancedMesh(
    new THREE.CylinderGeometry(0.08, 0.12, 6.8, 12),
    lampPoleMat,
    lampEntries.length
  );
  const lampArmMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(1.62, 0.12, 0.12), lampArmMat, lampEntries.length);
  const lampFixtureMesh = new THREE.InstancedMesh(
    new THREE.BoxGeometry(0.22, 0.12, 0.24),
    lampFixtureMat,
    lampEntries.length
  );
  const lampBulbMesh = new THREE.InstancedMesh(
    new THREE.SphereGeometry(0.18, 12, 10),
    lampBulbMat,
    lampEntries.length
  );
  for (const mesh of [lampPoleMesh, lampArmMesh, lampFixtureMesh, lampBulbMesh]) {
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    world.add(mesh);
  }

  const lampDummy = new THREE.Object3D();
  systems.lamps = {
    entries: lampEntries,
    bulbMaterial: lampBulbMat,
    activeCount: lampEntries.length,
    setDensity(density) {
      this.activeCount = Math.max(4, Math.floor(lampEntries.length * density));
      lampPoleMesh.count = this.activeCount;
      lampArmMesh.count = this.activeCount;
      lampFixtureMesh.count = this.activeCount;
      lampBulbMesh.count = this.activeCount;
    },
    update(dt, worldSpeed, recycleZ, roadLength, nowSeconds) {
      for (let i = 0; i < this.activeCount; i += 1) {
        const entry = lampEntries[i];
        entry.z += worldSpeed * dt * entry.speed;
        if (entry.z > recycleZ + 26) {
          entry.z -= roadLength;
        }

        lampDummy.position.set(entry.x, 3.4, entry.z);
        lampDummy.rotation.set(0, 0, 0);
        lampDummy.scale.set(1, 1, 1);
        lampDummy.updateMatrix();
        lampPoleMesh.setMatrixAt(i, lampDummy.matrix);

        lampDummy.position.set(entry.x - entry.side * 0.8, 6.42, entry.z);
        lampDummy.updateMatrix();
        lampArmMesh.setMatrixAt(i, lampDummy.matrix);

        lampDummy.position.set(entry.x - entry.side * 1.5, 6.3, entry.z);
        lampDummy.updateMatrix();
        lampFixtureMesh.setMatrixAt(i, lampDummy.matrix);

        lampDummy.position.set(entry.x - entry.side * 1.5, 6.15, entry.z);
        lampDummy.updateMatrix();
        lampBulbMesh.setMatrixAt(i, lampDummy.matrix);
      }
      lampPoleMesh.instanceMatrix.needsUpdate = true;
      lampArmMesh.instanceMatrix.needsUpdate = true;
      lampFixtureMesh.instanceMatrix.needsUpdate = true;
      lampBulbMesh.instanceMatrix.needsUpdate = true;

      const baseGlow = 0.28 + (1 - visualState.daylight) * 0.8 + visualState.rainStrength * 0.18;
      lampBulbMat.emissiveIntensity = baseGlow + Math.sin(nowSeconds * 1.1) * 0.08;
    }
  };
  systems.lamps.setDensity(qualityPreset.instanceDensity);
  systems.lamps.update(0, 0, config.recycleZ, config.roadLength, 0);

  const treeEntries = [];
  for (let z = -config.roadLength * 0.5; z < config.roadLength * 0.5; z += 10.5) {
    for (const side of [-1, 1]) {
      for (let row = 0; row < 2; row += 1) {
        if (Math.random() < 0.16) continue;
        treeEntries.push({
          x: side * (config.roadWidth * 0.5 + 5.8 + row * 2.5 + Math.random() * 1.4),
          z: z + (Math.random() - 0.5) * 4.6,
          scale: 0.82 + Math.random() * 0.58,
          trunkHeight: 1.6 + Math.random() * 1.6,
          phase: Math.random() * Math.PI * 2,
          sway: (0.004 + Math.random() * 0.01) * (Math.random() < 0.5 ? -1 : 1),
          speed: 0.82 + row * 0.07
        });
      }
    }
  }

  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x66503b, roughness: 0.95, metalness: 0.04 });
  const canopyLowerMat = new THREE.MeshStandardMaterial({ color: 0x426a4a, roughness: 0.95, metalness: 0.0 });
  const canopyUpperMat = new THREE.MeshStandardMaterial({ color: 0x355c3f, roughness: 0.97, metalness: 0.0 });
  const trunkMesh = new THREE.InstancedMesh(new THREE.CylinderGeometry(0.12, 0.17, 1, 8), trunkMat, treeEntries.length);
  const canopyLowerMesh = new THREE.InstancedMesh(
    new THREE.SphereGeometry(0.9, 12, 10),
    canopyLowerMat,
    treeEntries.length
  );
  const canopyUpperMesh = new THREE.InstancedMesh(
    new THREE.SphereGeometry(0.72, 11, 9),
    canopyUpperMat,
    treeEntries.length
  );
  for (const mesh of [trunkMesh, canopyLowerMesh, canopyUpperMesh]) {
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    world.add(mesh);
  }

  const treeDummy = new THREE.Object3D();
  systems.trees = {
    entries: treeEntries,
    activeCount: treeEntries.length,
    setDensity(density) {
      this.activeCount = Math.max(10, Math.floor(treeEntries.length * density));
      trunkMesh.count = this.activeCount;
      canopyLowerMesh.count = this.activeCount;
      canopyUpperMesh.count = this.activeCount;
    },
    update(dt, worldSpeed, recycleZ, roadLength, nowSeconds) {
      for (let i = 0; i < this.activeCount; i += 1) {
        const entry = treeEntries[i];
        entry.z += worldSpeed * dt * entry.speed;
        if (entry.z > recycleZ + 40) {
          entry.z -= roadLength;
        }

        const sway = Math.sin(nowSeconds * 0.8 + entry.phase) * entry.sway;
        treeDummy.position.set(entry.x, entry.trunkHeight * 0.5 * entry.scale, entry.z);
        treeDummy.rotation.set(0, 0, sway);
        treeDummy.scale.set(entry.scale, entry.trunkHeight * entry.scale, entry.scale);
        treeDummy.updateMatrix();
        trunkMesh.setMatrixAt(i, treeDummy.matrix);

        treeDummy.position.set(entry.x, (entry.trunkHeight + 0.5) * entry.scale, entry.z);
        treeDummy.rotation.set(0, 0, sway);
        treeDummy.scale.set(1.12 * entry.scale, 0.9 * entry.scale, 1.06 * entry.scale);
        treeDummy.updateMatrix();
        canopyLowerMesh.setMatrixAt(i, treeDummy.matrix);

        treeDummy.position.set(entry.x, (entry.trunkHeight + 1.12) * entry.scale, entry.z);
        treeDummy.rotation.set(0, 0, sway * 0.8);
        treeDummy.scale.set(0.9 * entry.scale, 0.75 * entry.scale, 0.88 * entry.scale);
        treeDummy.updateMatrix();
        canopyUpperMesh.setMatrixAt(i, treeDummy.matrix);
      }
      trunkMesh.instanceMatrix.needsUpdate = true;
      canopyLowerMesh.instanceMatrix.needsUpdate = true;
      canopyUpperMesh.instanceMatrix.needsUpdate = true;
    }
  };
  systems.trees.setDensity(qualityPreset.instanceDensity);
  systems.trees.update(0, 0, config.recycleZ, config.roadLength, 0);

  return systems;
}

function updateInstancedRoadside(instanceSystems, dt, nowSeconds, worldSpeed, config) {
  if (instanceSystems.guardrails) {
    instanceSystems.guardrails.update(dt, worldSpeed, config.recycleZ, config.roadLength);
  }
  if (instanceSystems.lamps) {
    instanceSystems.lamps.update(dt, worldSpeed, config.recycleZ, config.roadLength, nowSeconds);
  }
  if (instanceSystems.trees) {
    instanceSystems.trees.update(dt, worldSpeed, config.recycleZ, config.roadLength, nowSeconds);
  }
}

function loadOptionalTexture(loader, path) {
  return new Promise((resolve) => {
    loader.load(
      path,
      (texture) => resolve(texture),
      undefined,
      () => resolve(null)
    );
  });
}

async function loadOptionalRoadAssets(environmentRef, rendererRef) {
  const loader = new THREE.TextureLoader();
  const [baseColor, normal, roughness] = await Promise.all([
    loadOptionalTexture(loader, "./assets/asphalt_basecolor.jpg"),
    loadOptionalTexture(loader, "./assets/asphalt_normal.jpg"),
    loadOptionalTexture(loader, "./assets/asphalt_roughness.jpg")
  ]);

  if (!baseColor || !normal || !roughness) {
    if (baseColor) baseColor.dispose();
    if (normal) normal.dispose();
    if (roughness) roughness.dispose();
    return false;
  }

  configureTextureSampling(baseColor, rendererRef, {
    repeatX: 1,
    repeatY: 8,
    colorSpace: THREE.SRGBColorSpace,
    maxAnisotropy: 8
  });
  configureTextureSampling(normal, rendererRef, {
    repeatX: 1,
    repeatY: 8,
    maxAnisotropy: 8
  });
  configureTextureSampling(roughness, rendererRef, {
    repeatX: 1,
    repeatY: 8,
    maxAnisotropy: 8
  });

  environmentRef.roadMaterial.map = baseColor;
  environmentRef.roadMaterial.normalMap = normal;
  environmentRef.roadMaterial.roughnessMap = roughness;
  environmentRef.roadMaterial.needsUpdate = true;

  environmentRef.roadTexture = baseColor;
  environmentRef.roadBaseColorMap = baseColor;
  environmentRef.roadNormalMap = normal;
  environmentRef.roadRoughnessMap = roughness;
  return true;
}

function buildEnvironment(sceneRef, config, rendererRef, qualityPreset = qualityPresets[DEFAULT_QUALITY_LEVEL]) {
  const dashes = [];
  const markers = [];
  const markerReflectors = [];
  const lamps = [];
  const guardrails = [];
  const signboards = [];
  const trees = [];
  const utilityPoles = [];
  const cloudLayers = [];
  const mistLayers = [];

  const world = new THREE.Group();
  sceneRef.add(world);

  const groundTexture = createGroundTexture(rendererRef);
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(360, 920),
    new THREE.MeshStandardMaterial({
      map: groundTexture,
      color: 0x7c916d,
      roughness: 1.0,
      metalness: 0.0
    })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.04;
  ground.receiveShadow = true;
  world.add(ground);

  const farGround = new THREE.Mesh(
    new THREE.PlaneGeometry(620, 1700),
    new THREE.MeshStandardMaterial({ color: 0x7b8d9e, roughness: 1.0, metalness: 0.0 })
  );
  farGround.rotation.x = -Math.PI / 2;
  farGround.position.set(0, -0.42, -220);
  world.add(farGround);

  const roadPbrMaps = createAsphaltPbrMaps(rendererRef);
  const roadTexture = roadPbrMaps.baseColorMap;
  const roadMaterial = new THREE.MeshStandardMaterial({
    map: roadTexture,
    roughnessMap: roadPbrMaps.roughnessMap,
    normalMap: roadPbrMaps.normalMap,
    normalScale: new THREE.Vector2(0.6, 0.6),
    color: 0x7c8188,
    roughness: 0.95,
    metalness: 0.06
  });
  const road = new THREE.Mesh(new THREE.PlaneGeometry(config.roadWidth, config.roadLength), roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.position.y = 0.008;
  road.receiveShadow = true;
  world.add(road);

  const roadSheenTexture = createRoadSheenTexture(rendererRef);
  const roadSheenMaterial = new THREE.MeshStandardMaterial({
    map: roadSheenTexture,
    color: 0xadbed2,
    roughness: 0.18,
    metalness: 0.08,
    transparent: true,
    opacity: 0.1
  });
  const roadSheen = new THREE.Mesh(
    new THREE.PlaneGeometry(config.roadWidth * 0.94, config.roadLength),
    roadSheenMaterial
  );
  roadSheen.rotation.x = -Math.PI / 2;
  roadSheen.position.y = 0.02;
  roadSheen.receiveShadow = true;
  world.add(roadSheen);

  const roadWearTexture = createRoadWearTexture(rendererRef);
  const roadWearMaterial = new THREE.MeshStandardMaterial({
    map: roadWearTexture,
    color: 0x3b424a,
    roughness: 0.9,
    metalness: 0.02,
    transparent: true,
    opacity: 0.24
  });
  const roadWear = new THREE.Mesh(
    new THREE.PlaneGeometry(config.roadWidth * 0.64, config.roadLength),
    roadWearMaterial
  );
  roadWear.rotation.x = -Math.PI / 2;
  roadWear.position.y = 0.019;
  roadWear.receiveShadow = true;
  world.add(roadWear);

  const roadReflectionMaterial = new THREE.MeshPhysicalMaterial({
    color: 0x91a8c0,
    roughness: 0.18,
    metalness: 0.04,
    clearcoat: 0.46,
    clearcoatRoughness: 0.2,
    transparent: true,
    opacity: 0.14
  });
  const roadReflection = new THREE.Mesh(
    new THREE.PlaneGeometry(config.roadWidth * 0.86, config.roadLength),
    roadReflectionMaterial
  );
  roadReflection.rotation.x = -Math.PI / 2;
  roadReflection.position.y = 0.0215;
  roadReflection.receiveShadow = true;
  world.add(roadReflection);

  const laneMarkingsTexture = createLaneMarkingsTexture(rendererRef);
  const laneMarkingsMaterial = new THREE.MeshStandardMaterial({
    map: laneMarkingsTexture,
    color: 0xf6edd9,
    roughness: 0.64,
    metalness: 0.02,
    transparent: true,
    alphaTest: 0.12,
    opacity: 0.74,
    depthWrite: false
  });
  const laneMarkings = new THREE.Mesh(
    new THREE.PlaneGeometry(config.roadWidth * 0.98, config.roadLength),
    laneMarkingsMaterial
  );
  laneMarkings.rotation.x = -Math.PI / 2;
  laneMarkings.position.y = 0.024;
  laneMarkings.receiveShadow = true;
  world.add(laneMarkings);

  const shoulderTexture = createShoulderTexture(rendererRef);
  const shoulderMat = new THREE.MeshStandardMaterial({
    map: shoulderTexture,
    color: 0x8b9095,
    roughness: 0.92,
    metalness: 0.06
  });
  const shoulderWidth = 1.9;
  const shoulderOffset = config.roadWidth * 0.5 + shoulderWidth * 0.5;

  const leftShoulder = new THREE.Mesh(new THREE.PlaneGeometry(shoulderWidth, config.roadLength), shoulderMat);
  leftShoulder.rotation.x = -Math.PI / 2;
  leftShoulder.position.set(-shoulderOffset, 0.012, 0);
  leftShoulder.receiveShadow = true;
  world.add(leftShoulder);

  const rightShoulder = leftShoulder.clone();
  rightShoulder.position.x = shoulderOffset;
  world.add(rightShoulder);

  const shoulderBlendTexture = createShoulderBlendTexture(rendererRef);
  for (const side of [-1, 1]) {
    const shoulderBlend = new THREE.Mesh(
      new THREE.PlaneGeometry(1.2, config.roadLength),
      new THREE.MeshStandardMaterial({
        map: shoulderBlendTexture,
        color: 0xb4a78e,
        roughness: 0.98,
        metalness: 0.0,
        transparent: true,
        opacity: 0.62
      })
    );
    shoulderBlend.rotation.x = -Math.PI / 2;
    shoulderBlend.position.set(side * (config.roadWidth * 0.5 + 1.05), 0.015, 0);
    shoulderBlend.receiveShadow = true;
    world.add(shoulderBlend);
  }

  const vergeMat = new THREE.MeshStandardMaterial({ color: 0x718264, roughness: 0.96, metalness: 0.0 });
  for (const side of [-1, 1]) {
    const verge = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.45, config.roadLength), vergeMat);
    verge.position.set(side * (config.roadWidth * 0.5 + 3.5), 0.2, 0);
    verge.receiveShadow = true;
    world.add(verge);
  }
  const guardrailTextures = createGuardrailWearTextures(rendererRef);
  const instanceSystems = buildInstances(world, config, qualityPreset, guardrailTextures);

  for (let z = -config.roadLength * 0.5; z < config.roadLength * 0.5; z += 7.6) {
    for (const side of [-1, 1]) {
      const marker = new THREE.Group();

      const post = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.62, 0.12),
        new THREE.MeshStandardMaterial({ color: 0xd7dce2, roughness: 0.82, metalness: 0.08 })
      );
      post.position.y = 0.31;
      marker.add(post);

      const reflector = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.2, 0.09),
        new THREE.MeshStandardMaterial({ color: 0xff6a54, emissive: 0x692114, emissiveIntensity: 0.42 })
      );
      reflector.position.set(0, 0.46, side === -1 ? 0.03 : -0.03);
      marker.add(reflector);
      markerReflectors.push(reflector);

      marker.position.set(side * (config.roadWidth * 0.5 + 1.16), 0, z);
      world.add(marker);
      markers.push(marker);
    }
  }

  const poleMat = new THREE.MeshStandardMaterial({ color: 0x6d747c, roughness: 0.78, metalness: 0.26 });
  const crossMat = new THREE.MeshStandardMaterial({ color: 0x7e858d, roughness: 0.72, metalness: 0.24 });
  for (let z = -config.roadLength * 0.5; z < config.roadLength * 0.5; z += 34) {
    for (const side of [-1, 1]) {
      const poleGroup = new THREE.Group();

      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.14, 7, 10), poleMat);
      pole.position.y = 3.5;
      poleGroup.add(pole);

      const cross = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.11, 0.11), crossMat);
      cross.position.y = 6.6;
      poleGroup.add(cross);

      for (const offset of [-0.7, 0, 0.7]) {
        const insulator = new THREE.Mesh(
          new THREE.SphereGeometry(0.05, 10, 8),
          new THREE.MeshStandardMaterial({ color: 0xd0d5dc, roughness: 0.5, metalness: 0.12 })
        );
        insulator.position.set(offset, 6.53, 0);
        poleGroup.add(insulator);
      }

      poleGroup.position.set(side * (config.roadWidth * 0.5 + 9), 0, z + (Math.random() - 0.5) * 3);
      world.add(poleGroup);

      utilityPoles.push({
        group: poleGroup,
        speed: 0.9,
        phase: Math.random() * Math.PI * 2
      });
    }
  }

  const signColors = [0x2f628f, 0x39645b, 0x6f5743, 0x3f5878];
  for (let z = -config.roadLength * 0.5 + 18; z < config.roadLength * 0.5; z += 56) {
    const side = Math.random() < 0.5 ? -1 : 1;
    const sign = new THREE.Group();
    const signX = side * (config.roadWidth * 0.5 + 4.6);

    const pole = new THREE.Mesh(
      new THREE.CylinderGeometry(0.08, 0.11, 3.1, 12),
      new THREE.MeshStandardMaterial({ color: 0x6c7681, roughness: 0.74, metalness: 0.3 })
    );
    pole.position.y = 1.55;
    pole.castShadow = true;
    sign.add(pole);

    const board = new THREE.Mesh(
      new THREE.BoxGeometry(1.7, 0.84, 0.08),
      new THREE.MeshStandardMaterial({
        color: signColors[Math.floor(Math.random() * signColors.length)],
        roughness: 0.46,
        metalness: 0.28
      })
    );
    board.position.y = 2.44;
    board.castShadow = true;
    sign.add(board);

    for (let i = -1; i <= 1; i += 1) {
      const line = new THREE.Mesh(
        new THREE.BoxGeometry(1.28 - Math.abs(i) * 0.24, 0.06, 0.09),
        new THREE.MeshStandardMaterial({ color: 0xe7edf6, roughness: 0.3, metalness: 0.12 })
      );
      line.position.set(0, 2.44 + i * 0.2, 0.01);
      sign.add(line);
    }

    sign.position.set(signX, 0, z);
    world.add(sign);
    signboards.push(sign);
  }

  const mountainPalette = [0x76889c, 0x6a7f96, 0x8996a8, 0x778094];
  for (let i = 0; i < 24; i += 1) {
    const radius = 18 + Math.random() * 34;
    const height = 24 + Math.random() * 54;
    const mountain = new THREE.Mesh(
      new THREE.ConeGeometry(radius, height, 12),
      new THREE.MeshStandardMaterial({
        color: mountainPalette[Math.floor(Math.random() * mountainPalette.length)],
        roughness: 0.98,
        metalness: 0.01
      })
    );
    const side = Math.random() < 0.5 ? -1 : 1;
    mountain.position.set(side * (70 + Math.random() * 130), height * 0.5 - 4, -350 + Math.random() * 640);
    mountain.scale.z = 1.2 + Math.random() * 0.8;
    world.add(mountain);
  }

  for (let i = 0; i < 52; i += 1) {
    const w = 5 + Math.random() * 8;
    const h = 10 + Math.random() * 34;
    const d = 5 + Math.random() * 10;
    const emissive = 0.08 + Math.random() * 0.15;
    const block = new THREE.Mesh(
      new THREE.BoxGeometry(w, h, d),
      new THREE.MeshStandardMaterial({
        color: 0x6f7e8f,
        roughness: 0.94,
        metalness: 0.04,
        emissive: 0x1a2534,
        emissiveIntensity: emissive
      })
    );
    const side = Math.random() < 0.5 ? -1 : 1;
    block.position.set(side * (98 + Math.random() * 138), h * 0.5 - 2.8, -380 + Math.random() * 720);
    world.add(block);
  }

  const cloudTexture = createCloudTexture(rendererRef);
  for (let i = 0; i < 16; i += 1) {
    const width = 42 + Math.random() * 70;
    const height = 10 + Math.random() * 18;
    const cloud = new THREE.Mesh(
      new THREE.PlaneGeometry(width, height),
      new THREE.MeshBasicMaterial({
        map: cloudTexture,
        color: 0xffffff,
        transparent: true,
        opacity: 0.12 + Math.random() * 0.12,
        depthWrite: false
      })
    );
    cloud.position.set((Math.random() - 0.5) * 240, 48 + Math.random() * 40, -320 + Math.random() * 420);
    cloud.rotation.y = (Math.random() - 0.5) * 0.4;
    cloud.renderOrder = -3;
    sceneRef.add(cloud);

    cloudLayers.push({
      mesh: cloud,
      baseX: cloud.position.x,
      baseZ: cloud.position.z,
      drift: 0.08 + Math.random() * 0.16,
      driftWidth: 4 + Math.random() * 11,
      zDrift: 2 + Math.random() * 5,
      phase: Math.random() * Math.PI * 2,
      opacityScale: 0.8 + Math.random() * 0.6
    });
  }

  const sunDisk = new THREE.Mesh(
    new THREE.SphereGeometry(18, 22, 16),
    new THREE.MeshBasicMaterial({ color: 0xffd6a5 })
  );
  sunDisk.position.set(-72, 86, -330);
  sceneRef.add(sunDisk);

  const sunHalo = new THREE.Sprite(
    new THREE.SpriteMaterial({ color: 0xffeacb, transparent: true, opacity: 0.2, depthWrite: false })
  );
  sunHalo.scale.set(130, 130, 1);
  sunHalo.position.copy(sunDisk.position);
  sceneRef.add(sunHalo);

  const moonDisk = new THREE.Mesh(
    new THREE.SphereGeometry(12, 20, 14),
    new THREE.MeshBasicMaterial({ color: 0xd9e5ff })
  );
  moonDisk.position.set(92, 92, -360);
  sceneRef.add(moonDisk);

  const moonHalo = new THREE.Sprite(
    new THREE.SpriteMaterial({ color: 0xdce8ff, transparent: true, opacity: 0.16, depthWrite: false })
  );
  moonHalo.scale.set(110, 110, 1);
  moonHalo.position.copy(moonDisk.position);
  sceneRef.add(moonHalo);

  const mistTexture = createMistTexture(rendererRef);
  for (let i = 0; i < 8; i += 1) {
    const width = 90 + Math.random() * 90;
    const depth = 30 + Math.random() * 26;
    const mistMaterial = new THREE.MeshBasicMaterial({
      map: mistTexture,
      color: 0xd6e4f4,
      transparent: true,
      opacity: 0.08 + Math.random() * 0.06,
      depthWrite: false
    });
    const mist = new THREE.Mesh(new THREE.PlaneGeometry(width, depth), mistMaterial);
    mist.rotation.x = -Math.PI / 2;
    mist.position.set((Math.random() - 0.5) * 40, 0.32 + Math.random() * 0.5, -config.roadLength * 0.5 + i * 72);
    mist.renderOrder = 1;
    world.add(mist);
    mistLayers.push({
      mesh: mist,
      baseX: mist.position.x,
      phase: Math.random() * Math.PI * 2,
      drift: 4 + Math.random() * 10,
      speed: 0.68 + Math.random() * 0.32,
      opacityScale: 0.8 + Math.random() * 0.6
    });
  }

  const rainCount = 1200;
  const rainPositions = new Float32Array(rainCount * 3);
  const rainSpeeds = new Float32Array(rainCount);
  const rainDrifts = new Float32Array(rainCount);
  const rainMinZ = -config.roadLength * 0.6;
  const rainMaxZ = config.recycleZ + 36;

  for (let i = 0; i < rainCount; i += 1) {
    const index = i * 3;
    rainPositions[index] = (Math.random() - 0.5) * (config.roadWidth + 32);
    rainPositions[index + 1] = Math.random() * 42;
    rainPositions[index + 2] = rainMinZ + Math.random() * (rainMaxZ - rainMinZ);
    rainSpeeds[i] = 14 + Math.random() * 24;
    rainDrifts[i] = (Math.random() - 0.5) * 1.8;
  }

  const rainGeometry = new THREE.BufferGeometry();
  rainGeometry.setAttribute("position", new THREE.BufferAttribute(rainPositions, 3));
  const rainMaterial = new THREE.PointsMaterial({
    map: createRainDropTexture(rendererRef),
    color: 0xd4e9ff,
    transparent: true,
    opacity: 0.34,
    size: 0.22,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  const rainPoints = new THREE.Points(rainGeometry, rainMaterial);
  rainPoints.position.set(0, 5.4, 0);
  rainPoints.frustumCulled = false;
  sceneRef.add(rainPoints);

  const rainSystem = {
    points: rainPoints,
    geometry: rainGeometry,
    material: rainMaterial,
    positions: rainPositions,
    speeds: rainSpeeds,
    drifts: rainDrifts,
    count: rainCount,
    activeCount: rainCount,
    minY: -2,
    maxY: 42,
    minZ: rainMinZ,
    maxZ: rainMaxZ
  };

  return {
    world,
    dashes,
    markers,
    markerReflectors,
    lamps,
    guardrails,
    signboards,
    trees,
    utilityPoles,
    cloudLayers,
    mistLayers,
    rainSystem,
    sunDisk,
    sunHalo,
    moonDisk,
    moonHalo,
    groundTexture,
    roadMaterial,
    roadTexture,
    roadBaseColorMap: roadPbrMaps.baseColorMap,
    roadRoughnessMap: roadPbrMaps.roughnessMap,
    roadNormalMap: roadPbrMaps.normalMap,
    roadSheenMaterial,
    roadSheenTexture,
    roadWearMaterial,
    roadReflectionMaterial,
    roadWearTexture,
    laneMarkingsTexture,
    laneMarkingsMaterial,
    shoulderBlendTexture,
    instanceSystems,
    fogDensityScale: qualityPreset.fogDensityScale
  };
}

function buildPlayerCar() {
  const group = new THREE.Group();
  const wheels = [];
  const headlights = [];
  const headlightBeams = [];

  const paint = new THREE.MeshStandardMaterial({ color: 0x2f6fcf, roughness: 0.3, metalness: 0.56 });
  const trim = new THREE.MeshStandardMaterial({ color: 0x1d232e, roughness: 0.58, metalness: 0.2 });
  const glass = new THREE.MeshStandardMaterial({
    color: 0xb9d6f1,
    roughness: 0.08,
    metalness: 0.08,
    transparent: true,
    opacity: 0.86
  });

  const lowerBody = new THREE.Mesh(new THREE.BoxGeometry(2.04, 0.62, 4.65), paint);
  lowerBody.position.y = 0.58;
  lowerBody.castShadow = true;
  group.add(lowerBody);

  const frontCurve = new THREE.Mesh(new THREE.SphereGeometry(0.9, 20, 16), paint);
  frontCurve.scale.set(1.08, 0.56, 0.8);
  frontCurve.position.set(0, 0.66, -2.04);
  frontCurve.castShadow = true;
  group.add(frontCurve);

  const rearCurve = new THREE.Mesh(new THREE.SphereGeometry(0.88, 18, 14), paint);
  rearCurve.scale.set(1.05, 0.54, 0.74);
  rearCurve.position.set(0, 0.66, 2.06);
  rearCurve.castShadow = true;
  group.add(rearCurve);

  const roof = new THREE.Mesh(new THREE.CapsuleGeometry(0.67, 1.56, 8, 16), paint);
  roof.rotation.x = Math.PI / 2;
  roof.position.set(0, 1.08, -0.16);
  roof.castShadow = true;
  group.add(roof);

  const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.44, 0.52, 0.08), glass);
  windshield.position.set(0, 1.19, -1.02);
  windshield.rotation.x = -0.5;
  group.add(windshield);

  const rearWindow = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.42, 0.08), glass);
  rearWindow.position.set(0, 1.12, 0.87);
  rearWindow.rotation.x = 0.42;
  group.add(rearWindow);

  for (const side of [-1, 1]) {
    const sideWindow = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.36, 1.74), glass);
    sideWindow.position.set(side * 0.74, 1.11, -0.06);
    group.add(sideWindow);

    const mirror = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.16, 0.2), trim);
    mirror.position.set(side * 1.03, 1.02, -1.15);
    mirror.castShadow = true;
    group.add(mirror);
  }

  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x131416, roughness: 0.86, metalness: 0.18 });
  const rimMat = new THREE.MeshStandardMaterial({ color: 0x9da6b3, roughness: 0.34, metalness: 0.62 });
  const wheelPositions = [
    [-0.98, 0.4, -1.37],
    [0.98, 0.4, -1.37],
    [-0.98, 0.4, 1.37],
    [0.98, 0.4, 1.37]
  ];

  for (const [x, y, z] of wheelPositions) {
    const wheel = new THREE.Group();

    const tire = new THREE.Mesh(new THREE.CylinderGeometry(0.43, 0.43, 0.38, 24), wheelMat);
    tire.rotation.z = Math.PI / 2;
    tire.castShadow = true;
    wheel.add(tire);

    const rim = new THREE.Mesh(new THREE.CylinderGeometry(0.19, 0.19, 0.4, 16), rimMat);
    rim.rotation.z = Math.PI / 2;
    wheel.add(rim);

    wheel.position.set(x, y, z);
    group.add(wheel);
    wheels.push(wheel);
  }

  const grille = new THREE.Mesh(new THREE.BoxGeometry(1.36, 0.28, 0.09), trim);
  grille.position.set(0, 0.7, -2.31);
  grille.castShadow = true;
  group.add(grille);

  for (const side of [-1, 1]) {
    const headlight = new THREE.Mesh(
      new THREE.BoxGeometry(0.28, 0.16, 0.08),
      new THREE.MeshStandardMaterial({ color: 0xfff2d4, emissive: 0xffe4a8, emissiveIntensity: 0.95 })
    );
    headlight.position.set(side * 0.73, 0.86, -2.29);
    group.add(headlight);
    headlights.push(headlight);

    const beam = new THREE.SpotLight(0xfff2d1, 1.2, 42, Math.PI / 7.5, 0.58, 1.15);
    beam.position.set(side * 0.73, 0.86, -2.24);
    beam.target.position.set(side * 0.55, 0.08, -34);
    beam.castShadow = false;
    group.add(beam);
    group.add(beam.target);
    headlightBeams.push(beam);

    const tailLight = new THREE.Mesh(
      new THREE.BoxGeometry(0.22, 0.14, 0.07),
      new THREE.MeshStandardMaterial({ color: 0xff7362, emissive: 0xff2a22, emissiveIntensity: 0.65 })
    );
    tailLight.position.set(side * 0.75, 0.86, 2.33);
    group.add(tailLight);
  }

  const underShadow = new THREE.Mesh(
    new THREE.CircleGeometry(1.52, 30),
    new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 })
  );
  underShadow.rotation.x = -Math.PI / 2;
  underShadow.position.y = 0.03;
  underShadow.scale.set(1.0, 1.85, 1);
  group.add(underShadow);

  return { group, wheels, headlights, headlightBeams };
}

function createCoinReward() {
  const mesh = new THREE.Group();
  const ringMat = new THREE.MeshStandardMaterial({
    color: 0xf3c765,
    roughness: 0.3,
    metalness: 0.72,
    emissive: 0x835a17,
    emissiveIntensity: 0.58
  });
  const centerMat = new THREE.MeshStandardMaterial({
    color: 0xffe2a4,
    roughness: 0.24,
    metalness: 0.64,
    emissive: 0x8c631c,
    emissiveIntensity: 0.48
  });

  const ring = new THREE.Mesh(new THREE.TorusGeometry(0.48, 0.11, 18, 30), ringMat);
  ring.rotation.y = Math.PI / 2;
  mesh.add(ring);

  const center = new THREE.Mesh(new THREE.CylinderGeometry(0.24, 0.24, 0.12, 24), centerMat);
  center.rotation.z = Math.PI / 2;
  mesh.add(center);

  const glow = new THREE.Mesh(
    new THREE.SphereGeometry(0.35, 14, 10),
    new THREE.MeshStandardMaterial({
      color: 0xffcf7a,
      roughness: 0.6,
      metalness: 0.04,
      emissive: 0xffb04e,
      emissiveIntensity: 0.68,
      transparent: true,
      opacity: 0.26
    })
  );
  mesh.add(glow);

  return {
    type: "coin",
    mesh,
    width: 1.02,
    depth: 1.02,
    height: 0.95,
    baseScore: 70,
    spinSpeed: 2.8,
    glow,
    glowBase: 0.68
  };
}

function createNitroReward() {
  const mesh = new THREE.Group();
  const canMat = new THREE.MeshStandardMaterial({
    color: 0x87dcff,
    roughness: 0.24,
    metalness: 0.62,
    emissive: 0x1d4f6d,
    emissiveIntensity: 0.62
  });
  const capMat = new THREE.MeshStandardMaterial({ color: 0xcde8ff, roughness: 0.22, metalness: 0.76 });

  const canister = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.84, 20), canMat);
  canister.castShadow = true;
  mesh.add(canister);

  const capTop = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.16, 0.14, 18), capMat);
  capTop.position.y = 0.49;
  mesh.add(capTop);

  const capBottom = capTop.clone();
  capBottom.position.y = -0.49;
  mesh.add(capBottom);

  const glow = new THREE.Mesh(
    new THREE.SphereGeometry(0.42, 14, 10),
    new THREE.MeshStandardMaterial({
      color: 0x9cefff,
      roughness: 0.54,
      metalness: 0.04,
      emissive: 0x57d8ff,
      emissiveIntensity: 0.82,
      transparent: true,
      opacity: 0.24
    })
  );
  mesh.add(glow);

  return {
    type: "nitro",
    mesh,
    width: 0.9,
    depth: 0.9,
    height: 1.06,
    baseScore: 110,
    spinSpeed: 2.3,
    glow,
    glowBase: 0.82
  };
}

function createBarrierObstacle() {
  const mesh = new THREE.Group();
  const beacons = [];

  const base = new THREE.Mesh(
    new THREE.BoxGeometry(2.25, 0.7, 1.12),
    new THREE.MeshStandardMaterial({ color: 0xf07939, roughness: 0.52, metalness: 0.08 })
  );
  base.position.y = 0.35;
  base.castShadow = true;
  base.receiveShadow = true;
  mesh.add(base);

  const top = new THREE.Mesh(
    new THREE.BoxGeometry(2.34, 0.2, 0.3),
    new THREE.MeshStandardMaterial({ color: 0xff8d48, roughness: 0.47, metalness: 0.12 })
  );
  top.position.y = 0.82;
  top.castShadow = true;
  mesh.add(top);

  const stripeMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.42, metalness: 0.08 });
  for (let i = -1; i <= 1; i += 1) {
    const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.58, 0.12, 0.04), stripeMat);
    stripe.position.set(i * 0.72, 0.57, 0.57);
    stripe.rotation.z = i === 0 ? 0.35 : -0.35;
    mesh.add(stripe);
  }

  for (const side of [-1, 1]) {
    const beacon = new THREE.Mesh(
      new THREE.SphereGeometry(0.1, 12, 10),
      new THREE.MeshStandardMaterial({ color: 0xff6d60, emissive: 0xff3d2d, emissiveIntensity: 0.8 })
    );
    beacon.position.set(side * 1.0, 0.96, 0);
    mesh.add(beacon);
    beacons.push(beacon);
  }

  return {
    type: "barrier",
    mesh,
    width: 2.3,
    depth: 1.16,
    beacons
  };
}

function createConeClusterObstacle() {
  const mesh = new THREE.Group();
  const coneMat = new THREE.MeshStandardMaterial({ color: 0xff8b2d, roughness: 0.5, metalness: 0.05 });
  const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.34, metalness: 0.02 });

  const positions = [-0.7, 0, 0.7];
  for (const x of positions) {
    const cone = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.34, 0.92, 16), coneMat);
    cone.position.set(x, 0.46, 0);
    cone.castShadow = true;
    cone.receiveShadow = true;
    mesh.add(cone);

    const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.19, 0.04, 8, 16), stripeMat);
    stripe.rotation.x = Math.PI / 2;
    stripe.position.set(x, 0.5, 0);
    mesh.add(stripe);
  }

  const base = new THREE.Mesh(
    new THREE.BoxGeometry(2.02, 0.06, 0.92),
    new THREE.MeshStandardMaterial({ color: 0x34373d, roughness: 0.9, metalness: 0.1 })
  );
  base.position.y = 0.03;
  base.receiveShadow = true;
  mesh.add(base);

  return {
    type: "cones",
    mesh,
    width: 2.06,
    depth: 1.04
  };
}

function createTrafficCarObstacle() {
  const colors = [0xb8c1cf, 0x3f4c5d, 0xb64940, 0x8f9198, 0x2464a6, 0x556d3a];
  const color = colors[Math.floor(Math.random() * colors.length)];

  const mesh = new THREE.Group();
  const paint = new THREE.MeshStandardMaterial({ color, roughness: 0.35, metalness: 0.5 });
  const dark = new THREE.MeshStandardMaterial({ color: 0x1a1f25, roughness: 0.58, metalness: 0.2 });
  const glass = new THREE.MeshStandardMaterial({
    color: 0xaec4d8,
    roughness: 0.08,
    metalness: 0.08,
    transparent: true,
    opacity: 0.82
  });

  const body = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.58, 4.0), paint);
  body.position.y = 0.55;
  body.castShadow = true;
  body.receiveShadow = true;
  mesh.add(body);

  const roof = new THREE.Mesh(new THREE.CapsuleGeometry(0.56, 1.2, 8, 14), paint);
  roof.rotation.x = Math.PI / 2;
  roof.position.set(0, 0.96, -0.08);
  roof.castShadow = true;
  mesh.add(roof);

  const wind = new THREE.Mesh(new THREE.BoxGeometry(1.24, 0.44, 0.07), glass);
  wind.position.set(0, 1.06, -0.85);
  wind.rotation.x = -0.48;
  mesh.add(wind);

  const rearWind = new THREE.Mesh(new THREE.BoxGeometry(1.14, 0.36, 0.07), glass);
  rearWind.position.set(0, 1.0, 0.68);
  rearWind.rotation.x = 0.4;
  mesh.add(rearWind);

  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111316, roughness: 0.88, metalness: 0.15 });
  const wheelPos = [
    [-0.9, 0.37, -1.2],
    [0.9, 0.37, -1.2],
    [-0.9, 0.37, 1.2],
    [0.9, 0.37, 1.2]
  ];

  for (const [x, y, z] of wheelPos) {
    const tire = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.34, 20), wheelMat);
    tire.rotation.z = Math.PI / 2;
    tire.position.set(x, y, z);
    tire.castShadow = true;
    mesh.add(tire);
  }

  for (const side of [-1, 1]) {
    const tail = new THREE.Mesh(
      new THREE.BoxGeometry(0.2, 0.12, 0.06),
      new THREE.MeshStandardMaterial({ color: 0xff7c6d, emissive: 0xff3f33, emissiveIntensity: 0.58 })
    );
    tail.position.set(side * 0.66, 0.82, 2.04);
    mesh.add(tail);
  }

  const frontGrille = new THREE.Mesh(new THREE.BoxGeometry(1.18, 0.2, 0.08), dark);
  frontGrille.position.set(0, 0.68, -2.01);
  frontGrille.castShadow = true;
  mesh.add(frontGrille);

  return {
    type: "traffic_car",
    mesh,
    width: 1.94,
    depth: 4.06
  };
}

